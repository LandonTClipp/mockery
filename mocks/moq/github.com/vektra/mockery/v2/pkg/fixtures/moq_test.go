// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery

package test

import (
	"encoding/json"
	"io"
	"net/http"
	"sync"

	fixtures "github.com/vektra/mockery/v2/pkg/fixtures"
	number_dir_http "github.com/vektra/mockery/v2/pkg/fixtures/12345678/http"
	"github.com/vektra/mockery/v2/pkg/fixtures/constraints"
	my_http "github.com/vektra/mockery/v2/pkg/fixtures/http"
	redefinedtypeb "github.com/vektra/mockery/v2/pkg/fixtures/redefined_type_b"
)

// UsesAnyMock is a mock implementation of test.UsesAny.
//
//	func TestSomethingThatUsesUsesAny(t *testing.T) {
//
//		// make and configure a mocked test.UsesAny
//		mockedUsesAny := &UsesAnyMock{
//			GetReaderFunc: func() any {
//				panic("mock out the GetReader method")
//			},
//		}
//
//		// use mockedUsesAny in code that requires test.UsesAny
//		// and then make assertions.
//
//	}
type UsesAnyMock struct {
	// GetReaderFunc mocks the GetReader method.
	GetReaderFunc func() any

	// calls tracks calls to the methods.
	calls struct {
		// GetReader holds details about calls to the GetReader method.
		GetReader []struct {
		}
	}
	lockGetReader sync.RWMutex
}

// GetReader calls GetReaderFunc.
func (mock *UsesAnyMock) GetReader() any {
	if mock.GetReaderFunc == nil {
		panic("UsesAnyMock.GetReaderFunc: method is nil but UsesAny.GetReader was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetReader.Lock()
	mock.calls.GetReader = append(mock.calls.GetReader, callInfo)
	mock.lockGetReader.Unlock()
	return mock.GetReaderFunc()
}

// GetReaderCalls gets all the calls that were made to GetReader.
// Check the length with:
//
//	len(mockedUsesAny.GetReaderCalls())
func (mock *UsesAnyMock) GetReaderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetReader.RLock()
	calls = mock.calls.GetReader
	mock.lockGetReader.RUnlock()
	return calls
}

// ResetGetReaderCalls reset all the calls that were made to GetReader.
func (mock *UsesAnyMock) ResetGetReaderCalls() {
	mock.lockGetReader.Lock()
	mock.calls.GetReader = nil
	mock.lockGetReader.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *UsesAnyMock) ResetCalls() {
	mock.lockGetReader.Lock()
	mock.calls.GetReader = nil
	mock.lockGetReader.Unlock()
}

// FooerMock is a mock implementation of test.Fooer.
//
//	func TestSomethingThatUsesFooer(t *testing.T) {
//
//		// make and configure a mocked test.Fooer
//		mockedFooer := &FooerMock{
//			BarFunc: func(fParam func([]int))  {
//				panic("mock out the Bar method")
//			},
//			BazFunc: func(pathParam string) func(x string) string {
//				panic("mock out the Baz method")
//			},
//			FooFunc: func(fParam func(x string) string) error {
//				panic("mock out the Foo method")
//			},
//		}
//
//		// use mockedFooer in code that requires test.Fooer
//		// and then make assertions.
//
//	}
type FooerMock struct {
	// BarFunc mocks the Bar method.
	BarFunc func(fParam func([]int))

	// BazFunc mocks the Baz method.
	BazFunc func(pathParam string) func(x string) string

	// FooFunc mocks the Foo method.
	FooFunc func(fParam func(x string) string) error

	// calls tracks calls to the methods.
	calls struct {
		// Bar holds details about calls to the Bar method.
		Bar []struct {
			// FParam is the fParam argument value.
			FParam func([]int)
		}
		// Baz holds details about calls to the Baz method.
		Baz []struct {
			// PathParam is the pathParam argument value.
			PathParam string
		}
		// Foo holds details about calls to the Foo method.
		Foo []struct {
			// FParam is the fParam argument value.
			FParam func(x string) string
		}
	}
	lockBar sync.RWMutex
	lockBaz sync.RWMutex
	lockFoo sync.RWMutex
}

// Bar calls BarFunc.
func (mock *FooerMock) Bar(fParam func([]int)) {
	if mock.BarFunc == nil {
		panic("FooerMock.BarFunc: method is nil but Fooer.Bar was just called")
	}
	callInfo := struct {
		FParam func([]int)
	}{
		FParam: fParam,
	}
	mock.lockBar.Lock()
	mock.calls.Bar = append(mock.calls.Bar, callInfo)
	mock.lockBar.Unlock()
	mock.BarFunc(fParam)
}

// BarCalls gets all the calls that were made to Bar.
// Check the length with:
//
//	len(mockedFooer.BarCalls())
func (mock *FooerMock) BarCalls() []struct {
	FParam func([]int)
} {
	var calls []struct {
		FParam func([]int)
	}
	mock.lockBar.RLock()
	calls = mock.calls.Bar
	mock.lockBar.RUnlock()
	return calls
}

// ResetBarCalls reset all the calls that were made to Bar.
func (mock *FooerMock) ResetBarCalls() {
	mock.lockBar.Lock()
	mock.calls.Bar = nil
	mock.lockBar.Unlock()
}

// Baz calls BazFunc.
func (mock *FooerMock) Baz(pathParam string) func(x string) string {
	if mock.BazFunc == nil {
		panic("FooerMock.BazFunc: method is nil but Fooer.Baz was just called")
	}
	callInfo := struct {
		PathParam string
	}{
		PathParam: pathParam,
	}
	mock.lockBaz.Lock()
	mock.calls.Baz = append(mock.calls.Baz, callInfo)
	mock.lockBaz.Unlock()
	return mock.BazFunc(pathParam)
}

// BazCalls gets all the calls that were made to Baz.
// Check the length with:
//
//	len(mockedFooer.BazCalls())
func (mock *FooerMock) BazCalls() []struct {
	PathParam string
} {
	var calls []struct {
		PathParam string
	}
	mock.lockBaz.RLock()
	calls = mock.calls.Baz
	mock.lockBaz.RUnlock()
	return calls
}

// ResetBazCalls reset all the calls that were made to Baz.
func (mock *FooerMock) ResetBazCalls() {
	mock.lockBaz.Lock()
	mock.calls.Baz = nil
	mock.lockBaz.Unlock()
}

// Foo calls FooFunc.
func (mock *FooerMock) Foo(fParam func(x string) string) error {
	if mock.FooFunc == nil {
		panic("FooerMock.FooFunc: method is nil but Fooer.Foo was just called")
	}
	callInfo := struct {
		FParam func(x string) string
	}{
		FParam: fParam,
	}
	mock.lockFoo.Lock()
	mock.calls.Foo = append(mock.calls.Foo, callInfo)
	mock.lockFoo.Unlock()
	return mock.FooFunc(fParam)
}

// FooCalls gets all the calls that were made to Foo.
// Check the length with:
//
//	len(mockedFooer.FooCalls())
func (mock *FooerMock) FooCalls() []struct {
	FParam func(x string) string
} {
	var calls []struct {
		FParam func(x string) string
	}
	mock.lockFoo.RLock()
	calls = mock.calls.Foo
	mock.lockFoo.RUnlock()
	return calls
}

// ResetFooCalls reset all the calls that were made to Foo.
func (mock *FooerMock) ResetFooCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *FooerMock) ResetCalls() {
	mock.lockBar.Lock()
	mock.calls.Bar = nil
	mock.lockBar.Unlock()

	mock.lockBaz.Lock()
	mock.calls.Baz = nil
	mock.lockBaz.Unlock()

	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// MapFuncMock is a mock implementation of test.MapFunc.
//
//	func TestSomethingThatUsesMapFunc(t *testing.T) {
//
//		// make and configure a mocked test.MapFunc
//		mockedMapFunc := &MapFuncMock{
//			GetFunc: func(mParam map[string]func(string) string) error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedMapFunc in code that requires test.MapFunc
//		// and then make assertions.
//
//	}
type MapFuncMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(mParam map[string]func(string) string) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// MParam is the mParam argument value.
			MParam map[string]func(string) string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MapFuncMock) Get(mParam map[string]func(string) string) error {
	if mock.GetFunc == nil {
		panic("MapFuncMock.GetFunc: method is nil but MapFunc.Get was just called")
	}
	callInfo := struct {
		MParam map[string]func(string) string
	}{
		MParam: mParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(mParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedMapFunc.GetCalls())
func (mock *MapFuncMock) GetCalls() []struct {
	MParam map[string]func(string) string
} {
	var calls []struct {
		MParam map[string]func(string) string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MapFuncMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MapFuncMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// AsyncProducerMock is a mock implementation of test.AsyncProducer.
//
//	func TestSomethingThatUsesAsyncProducer(t *testing.T) {
//
//		// make and configure a mocked test.AsyncProducer
//		mockedAsyncProducer := &AsyncProducerMock{
//			InputFunc: func() chan<- bool {
//				panic("mock out the Input method")
//			},
//			OutputFunc: func() <-chan bool {
//				panic("mock out the Output method")
//			},
//			WhateverFunc: func() chan bool {
//				panic("mock out the Whatever method")
//			},
//		}
//
//		// use mockedAsyncProducer in code that requires test.AsyncProducer
//		// and then make assertions.
//
//	}
type AsyncProducerMock struct {
	// InputFunc mocks the Input method.
	InputFunc func() chan<- bool

	// OutputFunc mocks the Output method.
	OutputFunc func() <-chan bool

	// WhateverFunc mocks the Whatever method.
	WhateverFunc func() chan bool

	// calls tracks calls to the methods.
	calls struct {
		// Input holds details about calls to the Input method.
		Input []struct {
		}
		// Output holds details about calls to the Output method.
		Output []struct {
		}
		// Whatever holds details about calls to the Whatever method.
		Whatever []struct {
		}
	}
	lockInput    sync.RWMutex
	lockOutput   sync.RWMutex
	lockWhatever sync.RWMutex
}

// Input calls InputFunc.
func (mock *AsyncProducerMock) Input() chan<- bool {
	if mock.InputFunc == nil {
		panic("AsyncProducerMock.InputFunc: method is nil but AsyncProducer.Input was just called")
	}
	callInfo := struct {
	}{}
	mock.lockInput.Lock()
	mock.calls.Input = append(mock.calls.Input, callInfo)
	mock.lockInput.Unlock()
	return mock.InputFunc()
}

// InputCalls gets all the calls that were made to Input.
// Check the length with:
//
//	len(mockedAsyncProducer.InputCalls())
func (mock *AsyncProducerMock) InputCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInput.RLock()
	calls = mock.calls.Input
	mock.lockInput.RUnlock()
	return calls
}

// ResetInputCalls reset all the calls that were made to Input.
func (mock *AsyncProducerMock) ResetInputCalls() {
	mock.lockInput.Lock()
	mock.calls.Input = nil
	mock.lockInput.Unlock()
}

// Output calls OutputFunc.
func (mock *AsyncProducerMock) Output() <-chan bool {
	if mock.OutputFunc == nil {
		panic("AsyncProducerMock.OutputFunc: method is nil but AsyncProducer.Output was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOutput.Lock()
	mock.calls.Output = append(mock.calls.Output, callInfo)
	mock.lockOutput.Unlock()
	return mock.OutputFunc()
}

// OutputCalls gets all the calls that were made to Output.
// Check the length with:
//
//	len(mockedAsyncProducer.OutputCalls())
func (mock *AsyncProducerMock) OutputCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOutput.RLock()
	calls = mock.calls.Output
	mock.lockOutput.RUnlock()
	return calls
}

// ResetOutputCalls reset all the calls that were made to Output.
func (mock *AsyncProducerMock) ResetOutputCalls() {
	mock.lockOutput.Lock()
	mock.calls.Output = nil
	mock.lockOutput.Unlock()
}

// Whatever calls WhateverFunc.
func (mock *AsyncProducerMock) Whatever() chan bool {
	if mock.WhateverFunc == nil {
		panic("AsyncProducerMock.WhateverFunc: method is nil but AsyncProducer.Whatever was just called")
	}
	callInfo := struct {
	}{}
	mock.lockWhatever.Lock()
	mock.calls.Whatever = append(mock.calls.Whatever, callInfo)
	mock.lockWhatever.Unlock()
	return mock.WhateverFunc()
}

// WhateverCalls gets all the calls that were made to Whatever.
// Check the length with:
//
//	len(mockedAsyncProducer.WhateverCalls())
func (mock *AsyncProducerMock) WhateverCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWhatever.RLock()
	calls = mock.calls.Whatever
	mock.lockWhatever.RUnlock()
	return calls
}

// ResetWhateverCalls reset all the calls that were made to Whatever.
func (mock *AsyncProducerMock) ResetWhateverCalls() {
	mock.lockWhatever.Lock()
	mock.calls.Whatever = nil
	mock.lockWhatever.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *AsyncProducerMock) ResetCalls() {
	mock.lockInput.Lock()
	mock.calls.Input = nil
	mock.lockInput.Unlock()

	mock.lockOutput.Lock()
	mock.calls.Output = nil
	mock.lockOutput.Unlock()

	mock.lockWhatever.Lock()
	mock.calls.Whatever = nil
	mock.lockWhatever.Unlock()
}

// ConsulLockMock is a mock implementation of test.ConsulLock.
//
//	func TestSomethingThatUsesConsulLock(t *testing.T) {
//
//		// make and configure a mocked test.ConsulLock
//		mockedConsulLock := &ConsulLockMock{
//			LockFunc: func(valChParam <-chan struct{}) (<-chan struct{}, error) {
//				panic("mock out the Lock method")
//			},
//			UnlockFunc: func() error {
//				panic("mock out the Unlock method")
//			},
//		}
//
//		// use mockedConsulLock in code that requires test.ConsulLock
//		// and then make assertions.
//
//	}
type ConsulLockMock struct {
	// LockFunc mocks the Lock method.
	LockFunc func(valChParam <-chan struct{}) (<-chan struct{}, error)

	// UnlockFunc mocks the Unlock method.
	UnlockFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Lock holds details about calls to the Lock method.
		Lock []struct {
			// ValChParam is the valChParam argument value.
			ValChParam <-chan struct{}
		}
		// Unlock holds details about calls to the Unlock method.
		Unlock []struct {
		}
	}
	lockLock   sync.RWMutex
	lockUnlock sync.RWMutex
}

// Lock calls LockFunc.
func (mock *ConsulLockMock) Lock(valChParam <-chan struct{}) (<-chan struct{}, error) {
	if mock.LockFunc == nil {
		panic("ConsulLockMock.LockFunc: method is nil but ConsulLock.Lock was just called")
	}
	callInfo := struct {
		ValChParam <-chan struct{}
	}{
		ValChParam: valChParam,
	}
	mock.lockLock.Lock()
	mock.calls.Lock = append(mock.calls.Lock, callInfo)
	mock.lockLock.Unlock()
	return mock.LockFunc(valChParam)
}

// LockCalls gets all the calls that were made to Lock.
// Check the length with:
//
//	len(mockedConsulLock.LockCalls())
func (mock *ConsulLockMock) LockCalls() []struct {
	ValChParam <-chan struct{}
} {
	var calls []struct {
		ValChParam <-chan struct{}
	}
	mock.lockLock.RLock()
	calls = mock.calls.Lock
	mock.lockLock.RUnlock()
	return calls
}

// ResetLockCalls reset all the calls that were made to Lock.
func (mock *ConsulLockMock) ResetLockCalls() {
	mock.lockLock.Lock()
	mock.calls.Lock = nil
	mock.lockLock.Unlock()
}

// Unlock calls UnlockFunc.
func (mock *ConsulLockMock) Unlock() error {
	if mock.UnlockFunc == nil {
		panic("ConsulLockMock.UnlockFunc: method is nil but ConsulLock.Unlock was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUnlock.Lock()
	mock.calls.Unlock = append(mock.calls.Unlock, callInfo)
	mock.lockUnlock.Unlock()
	return mock.UnlockFunc()
}

// UnlockCalls gets all the calls that were made to Unlock.
// Check the length with:
//
//	len(mockedConsulLock.UnlockCalls())
func (mock *ConsulLockMock) UnlockCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUnlock.RLock()
	calls = mock.calls.Unlock
	mock.lockUnlock.RUnlock()
	return calls
}

// ResetUnlockCalls reset all the calls that were made to Unlock.
func (mock *ConsulLockMock) ResetUnlockCalls() {
	mock.lockUnlock.Lock()
	mock.calls.Unlock = nil
	mock.lockUnlock.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ConsulLockMock) ResetCalls() {
	mock.lockLock.Lock()
	mock.calls.Lock = nil
	mock.lockLock.Unlock()

	mock.lockUnlock.Lock()
	mock.calls.Unlock = nil
	mock.lockUnlock.Unlock()
}

// KeyManagerMock is a mock implementation of test.KeyManager.
//
//	func TestSomethingThatUsesKeyManager(t *testing.T) {
//
//		// make and configure a mocked test.KeyManager
//		mockedKeyManager := &KeyManagerMock{
//			GetKeyFunc: func(sParam string, vParam uint16) ([]byte, *fixtures.Err) {
//				panic("mock out the GetKey method")
//			},
//		}
//
//		// use mockedKeyManager in code that requires test.KeyManager
//		// and then make assertions.
//
//	}
type KeyManagerMock struct {
	// GetKeyFunc mocks the GetKey method.
	GetKeyFunc func(sParam string, vParam uint16) ([]byte, *fixtures.Err)

	// calls tracks calls to the methods.
	calls struct {
		// GetKey holds details about calls to the GetKey method.
		GetKey []struct {
			// SParam is the sParam argument value.
			SParam string
			// VParam is the vParam argument value.
			VParam uint16
		}
	}
	lockGetKey sync.RWMutex
}

// GetKey calls GetKeyFunc.
func (mock *KeyManagerMock) GetKey(sParam string, vParam uint16) ([]byte, *fixtures.Err) {
	if mock.GetKeyFunc == nil {
		panic("KeyManagerMock.GetKeyFunc: method is nil but KeyManager.GetKey was just called")
	}
	callInfo := struct {
		SParam string
		VParam uint16
	}{
		SParam: sParam,
		VParam: vParam,
	}
	mock.lockGetKey.Lock()
	mock.calls.GetKey = append(mock.calls.GetKey, callInfo)
	mock.lockGetKey.Unlock()
	return mock.GetKeyFunc(sParam, vParam)
}

// GetKeyCalls gets all the calls that were made to GetKey.
// Check the length with:
//
//	len(mockedKeyManager.GetKeyCalls())
func (mock *KeyManagerMock) GetKeyCalls() []struct {
	SParam string
	VParam uint16
} {
	var calls []struct {
		SParam string
		VParam uint16
	}
	mock.lockGetKey.RLock()
	calls = mock.calls.GetKey
	mock.lockGetKey.RUnlock()
	return calls
}

// ResetGetKeyCalls reset all the calls that were made to GetKey.
func (mock *KeyManagerMock) ResetGetKeyCalls() {
	mock.lockGetKey.Lock()
	mock.calls.GetKey = nil
	mock.lockGetKey.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *KeyManagerMock) ResetCalls() {
	mock.lockGetKey.Lock()
	mock.calls.GetKey = nil
	mock.lockGetKey.Unlock()
}

// BlankMock is a mock implementation of test.Blank.
//
//	func TestSomethingThatUsesBlank(t *testing.T) {
//
//		// make and configure a mocked test.Blank
//		mockedBlank := &BlankMock{
//			CreateFunc: func(xParam interface{}) error {
//				panic("mock out the Create method")
//			},
//		}
//
//		// use mockedBlank in code that requires test.Blank
//		// and then make assertions.
//
//	}
type BlankMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(xParam interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// XParam is the xParam argument value.
			XParam interface{}
		}
	}
	lockCreate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *BlankMock) Create(xParam interface{}) error {
	if mock.CreateFunc == nil {
		panic("BlankMock.CreateFunc: method is nil but Blank.Create was just called")
	}
	callInfo := struct {
		XParam interface{}
	}{
		XParam: xParam,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(xParam)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedBlank.CreateCalls())
func (mock *BlankMock) CreateCalls() []struct {
	XParam interface{}
} {
	var calls []struct {
		XParam interface{}
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// ResetCreateCalls reset all the calls that were made to Create.
func (mock *BlankMock) ResetCreateCalls() {
	mock.lockCreate.Lock()
	mock.calls.Create = nil
	mock.lockCreate.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *BlankMock) ResetCalls() {
	mock.lockCreate.Lock()
	mock.calls.Create = nil
	mock.lockCreate.Unlock()
}

// ExpecterMock is a mock implementation of test.Expecter.
//
//	func TestSomethingThatUsesExpecter(t *testing.T) {
//
//		// make and configure a mocked test.Expecter
//		mockedExpecter := &ExpecterMock{
//			ManyArgsReturnsFunc: func(strParam string, iParam int) ([]string, error) {
//				panic("mock out the ManyArgsReturns method")
//			},
//			NoArgFunc: func() string {
//				panic("mock out the NoArg method")
//			},
//			NoReturnFunc: func(strParam string)  {
//				panic("mock out the NoReturn method")
//			},
//			VariadicFunc: func(intsParam ...int) error {
//				panic("mock out the Variadic method")
//			},
//			VariadicManyFunc: func(iParam int, aParam string, intfsParam ...interface{}) error {
//				panic("mock out the VariadicMany method")
//			},
//		}
//
//		// use mockedExpecter in code that requires test.Expecter
//		// and then make assertions.
//
//	}
type ExpecterMock struct {
	// ManyArgsReturnsFunc mocks the ManyArgsReturns method.
	ManyArgsReturnsFunc func(strParam string, iParam int) ([]string, error)

	// NoArgFunc mocks the NoArg method.
	NoArgFunc func() string

	// NoReturnFunc mocks the NoReturn method.
	NoReturnFunc func(strParam string)

	// VariadicFunc mocks the Variadic method.
	VariadicFunc func(intsParam ...int) error

	// VariadicManyFunc mocks the VariadicMany method.
	VariadicManyFunc func(iParam int, aParam string, intfsParam ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// ManyArgsReturns holds details about calls to the ManyArgsReturns method.
		ManyArgsReturns []struct {
			// StrParam is the strParam argument value.
			StrParam string
			// IParam is the iParam argument value.
			IParam int
		}
		// NoArg holds details about calls to the NoArg method.
		NoArg []struct {
		}
		// NoReturn holds details about calls to the NoReturn method.
		NoReturn []struct {
			// StrParam is the strParam argument value.
			StrParam string
		}
		// Variadic holds details about calls to the Variadic method.
		Variadic []struct {
			// IntsParam is the intsParam argument value.
			IntsParam []int
		}
		// VariadicMany holds details about calls to the VariadicMany method.
		VariadicMany []struct {
			// IParam is the iParam argument value.
			IParam int
			// AParam is the aParam argument value.
			AParam string
			// IntfsParam is the intfsParam argument value.
			IntfsParam []interface{}
		}
	}
	lockManyArgsReturns sync.RWMutex
	lockNoArg           sync.RWMutex
	lockNoReturn        sync.RWMutex
	lockVariadic        sync.RWMutex
	lockVariadicMany    sync.RWMutex
}

// ManyArgsReturns calls ManyArgsReturnsFunc.
func (mock *ExpecterMock) ManyArgsReturns(strParam string, iParam int) ([]string, error) {
	if mock.ManyArgsReturnsFunc == nil {
		panic("ExpecterMock.ManyArgsReturnsFunc: method is nil but Expecter.ManyArgsReturns was just called")
	}
	callInfo := struct {
		StrParam string
		IParam   int
	}{
		StrParam: strParam,
		IParam:   iParam,
	}
	mock.lockManyArgsReturns.Lock()
	mock.calls.ManyArgsReturns = append(mock.calls.ManyArgsReturns, callInfo)
	mock.lockManyArgsReturns.Unlock()
	return mock.ManyArgsReturnsFunc(strParam, iParam)
}

// ManyArgsReturnsCalls gets all the calls that were made to ManyArgsReturns.
// Check the length with:
//
//	len(mockedExpecter.ManyArgsReturnsCalls())
func (mock *ExpecterMock) ManyArgsReturnsCalls() []struct {
	StrParam string
	IParam   int
} {
	var calls []struct {
		StrParam string
		IParam   int
	}
	mock.lockManyArgsReturns.RLock()
	calls = mock.calls.ManyArgsReturns
	mock.lockManyArgsReturns.RUnlock()
	return calls
}

// ResetManyArgsReturnsCalls reset all the calls that were made to ManyArgsReturns.
func (mock *ExpecterMock) ResetManyArgsReturnsCalls() {
	mock.lockManyArgsReturns.Lock()
	mock.calls.ManyArgsReturns = nil
	mock.lockManyArgsReturns.Unlock()
}

// NoArg calls NoArgFunc.
func (mock *ExpecterMock) NoArg() string {
	if mock.NoArgFunc == nil {
		panic("ExpecterMock.NoArgFunc: method is nil but Expecter.NoArg was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNoArg.Lock()
	mock.calls.NoArg = append(mock.calls.NoArg, callInfo)
	mock.lockNoArg.Unlock()
	return mock.NoArgFunc()
}

// NoArgCalls gets all the calls that were made to NoArg.
// Check the length with:
//
//	len(mockedExpecter.NoArgCalls())
func (mock *ExpecterMock) NoArgCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNoArg.RLock()
	calls = mock.calls.NoArg
	mock.lockNoArg.RUnlock()
	return calls
}

// ResetNoArgCalls reset all the calls that were made to NoArg.
func (mock *ExpecterMock) ResetNoArgCalls() {
	mock.lockNoArg.Lock()
	mock.calls.NoArg = nil
	mock.lockNoArg.Unlock()
}

// NoReturn calls NoReturnFunc.
func (mock *ExpecterMock) NoReturn(strParam string) {
	if mock.NoReturnFunc == nil {
		panic("ExpecterMock.NoReturnFunc: method is nil but Expecter.NoReturn was just called")
	}
	callInfo := struct {
		StrParam string
	}{
		StrParam: strParam,
	}
	mock.lockNoReturn.Lock()
	mock.calls.NoReturn = append(mock.calls.NoReturn, callInfo)
	mock.lockNoReturn.Unlock()
	mock.NoReturnFunc(strParam)
}

// NoReturnCalls gets all the calls that were made to NoReturn.
// Check the length with:
//
//	len(mockedExpecter.NoReturnCalls())
func (mock *ExpecterMock) NoReturnCalls() []struct {
	StrParam string
} {
	var calls []struct {
		StrParam string
	}
	mock.lockNoReturn.RLock()
	calls = mock.calls.NoReturn
	mock.lockNoReturn.RUnlock()
	return calls
}

// ResetNoReturnCalls reset all the calls that were made to NoReturn.
func (mock *ExpecterMock) ResetNoReturnCalls() {
	mock.lockNoReturn.Lock()
	mock.calls.NoReturn = nil
	mock.lockNoReturn.Unlock()
}

// Variadic calls VariadicFunc.
func (mock *ExpecterMock) Variadic(intsParam ...int) error {
	if mock.VariadicFunc == nil {
		panic("ExpecterMock.VariadicFunc: method is nil but Expecter.Variadic was just called")
	}
	callInfo := struct {
		IntsParam []int
	}{
		IntsParam: intsParam,
	}
	mock.lockVariadic.Lock()
	mock.calls.Variadic = append(mock.calls.Variadic, callInfo)
	mock.lockVariadic.Unlock()
	return mock.VariadicFunc(intsParam...)
}

// VariadicCalls gets all the calls that were made to Variadic.
// Check the length with:
//
//	len(mockedExpecter.VariadicCalls())
func (mock *ExpecterMock) VariadicCalls() []struct {
	IntsParam []int
} {
	var calls []struct {
		IntsParam []int
	}
	mock.lockVariadic.RLock()
	calls = mock.calls.Variadic
	mock.lockVariadic.RUnlock()
	return calls
}

// ResetVariadicCalls reset all the calls that were made to Variadic.
func (mock *ExpecterMock) ResetVariadicCalls() {
	mock.lockVariadic.Lock()
	mock.calls.Variadic = nil
	mock.lockVariadic.Unlock()
}

// VariadicMany calls VariadicManyFunc.
func (mock *ExpecterMock) VariadicMany(iParam int, aParam string, intfsParam ...interface{}) error {
	if mock.VariadicManyFunc == nil {
		panic("ExpecterMock.VariadicManyFunc: method is nil but Expecter.VariadicMany was just called")
	}
	callInfo := struct {
		IParam     int
		AParam     string
		IntfsParam []interface{}
	}{
		IParam:     iParam,
		AParam:     aParam,
		IntfsParam: intfsParam,
	}
	mock.lockVariadicMany.Lock()
	mock.calls.VariadicMany = append(mock.calls.VariadicMany, callInfo)
	mock.lockVariadicMany.Unlock()
	return mock.VariadicManyFunc(iParam, aParam, intfsParam...)
}

// VariadicManyCalls gets all the calls that were made to VariadicMany.
// Check the length with:
//
//	len(mockedExpecter.VariadicManyCalls())
func (mock *ExpecterMock) VariadicManyCalls() []struct {
	IParam     int
	AParam     string
	IntfsParam []interface{}
} {
	var calls []struct {
		IParam     int
		AParam     string
		IntfsParam []interface{}
	}
	mock.lockVariadicMany.RLock()
	calls = mock.calls.VariadicMany
	mock.lockVariadicMany.RUnlock()
	return calls
}

// ResetVariadicManyCalls reset all the calls that were made to VariadicMany.
func (mock *ExpecterMock) ResetVariadicManyCalls() {
	mock.lockVariadicMany.Lock()
	mock.calls.VariadicMany = nil
	mock.lockVariadicMany.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ExpecterMock) ResetCalls() {
	mock.lockManyArgsReturns.Lock()
	mock.calls.ManyArgsReturns = nil
	mock.lockManyArgsReturns.Unlock()

	mock.lockNoArg.Lock()
	mock.calls.NoArg = nil
	mock.lockNoArg.Unlock()

	mock.lockNoReturn.Lock()
	mock.calls.NoReturn = nil
	mock.lockNoReturn.Unlock()

	mock.lockVariadic.Lock()
	mock.calls.Variadic = nil
	mock.lockVariadic.Unlock()

	mock.lockVariadicMany.Lock()
	mock.calls.VariadicMany = nil
	mock.lockVariadicMany.Unlock()
}

// VariadicNoReturnInterfaceMock is a mock implementation of test.VariadicNoReturnInterface.
//
//	func TestSomethingThatUsesVariadicNoReturnInterface(t *testing.T) {
//
//		// make and configure a mocked test.VariadicNoReturnInterface
//		mockedVariadicNoReturnInterface := &VariadicNoReturnInterfaceMock{
//			VariadicNoReturnFunc: func(jParam int, isParam ...interface{})  {
//				panic("mock out the VariadicNoReturn method")
//			},
//		}
//
//		// use mockedVariadicNoReturnInterface in code that requires test.VariadicNoReturnInterface
//		// and then make assertions.
//
//	}
type VariadicNoReturnInterfaceMock struct {
	// VariadicNoReturnFunc mocks the VariadicNoReturn method.
	VariadicNoReturnFunc func(jParam int, isParam ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// VariadicNoReturn holds details about calls to the VariadicNoReturn method.
		VariadicNoReturn []struct {
			// JParam is the jParam argument value.
			JParam int
			// IsParam is the isParam argument value.
			IsParam []interface{}
		}
	}
	lockVariadicNoReturn sync.RWMutex
}

// VariadicNoReturn calls VariadicNoReturnFunc.
func (mock *VariadicNoReturnInterfaceMock) VariadicNoReturn(jParam int, isParam ...interface{}) {
	if mock.VariadicNoReturnFunc == nil {
		panic("VariadicNoReturnInterfaceMock.VariadicNoReturnFunc: method is nil but VariadicNoReturnInterface.VariadicNoReturn was just called")
	}
	callInfo := struct {
		JParam  int
		IsParam []interface{}
	}{
		JParam:  jParam,
		IsParam: isParam,
	}
	mock.lockVariadicNoReturn.Lock()
	mock.calls.VariadicNoReturn = append(mock.calls.VariadicNoReturn, callInfo)
	mock.lockVariadicNoReturn.Unlock()
	mock.VariadicNoReturnFunc(jParam, isParam...)
}

// VariadicNoReturnCalls gets all the calls that were made to VariadicNoReturn.
// Check the length with:
//
//	len(mockedVariadicNoReturnInterface.VariadicNoReturnCalls())
func (mock *VariadicNoReturnInterfaceMock) VariadicNoReturnCalls() []struct {
	JParam  int
	IsParam []interface{}
} {
	var calls []struct {
		JParam  int
		IsParam []interface{}
	}
	mock.lockVariadicNoReturn.RLock()
	calls = mock.calls.VariadicNoReturn
	mock.lockVariadicNoReturn.RUnlock()
	return calls
}

// ResetVariadicNoReturnCalls reset all the calls that were made to VariadicNoReturn.
func (mock *VariadicNoReturnInterfaceMock) ResetVariadicNoReturnCalls() {
	mock.lockVariadicNoReturn.Lock()
	mock.calls.VariadicNoReturn = nil
	mock.lockVariadicNoReturn.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *VariadicNoReturnInterfaceMock) ResetCalls() {
	mock.lockVariadicNoReturn.Lock()
	mock.calls.VariadicNoReturn = nil
	mock.lockVariadicNoReturn.Unlock()
}

// FuncArgsCollisionMock is a mock implementation of test.FuncArgsCollision.
//
//	func TestSomethingThatUsesFuncArgsCollision(t *testing.T) {
//
//		// make and configure a mocked test.FuncArgsCollision
//		mockedFuncArgsCollision := &FuncArgsCollisionMock{
//			FooFunc: func(retParam interface{}) error {
//				panic("mock out the Foo method")
//			},
//		}
//
//		// use mockedFuncArgsCollision in code that requires test.FuncArgsCollision
//		// and then make assertions.
//
//	}
type FuncArgsCollisionMock struct {
	// FooFunc mocks the Foo method.
	FooFunc func(retParam interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Foo holds details about calls to the Foo method.
		Foo []struct {
			// RetParam is the retParam argument value.
			RetParam interface{}
		}
	}
	lockFoo sync.RWMutex
}

// Foo calls FooFunc.
func (mock *FuncArgsCollisionMock) Foo(retParam interface{}) error {
	if mock.FooFunc == nil {
		panic("FuncArgsCollisionMock.FooFunc: method is nil but FuncArgsCollision.Foo was just called")
	}
	callInfo := struct {
		RetParam interface{}
	}{
		RetParam: retParam,
	}
	mock.lockFoo.Lock()
	mock.calls.Foo = append(mock.calls.Foo, callInfo)
	mock.lockFoo.Unlock()
	return mock.FooFunc(retParam)
}

// FooCalls gets all the calls that were made to Foo.
// Check the length with:
//
//	len(mockedFuncArgsCollision.FooCalls())
func (mock *FuncArgsCollisionMock) FooCalls() []struct {
	RetParam interface{}
} {
	var calls []struct {
		RetParam interface{}
	}
	mock.lockFoo.RLock()
	calls = mock.calls.Foo
	mock.lockFoo.RUnlock()
	return calls
}

// ResetFooCalls reset all the calls that were made to Foo.
func (mock *FuncArgsCollisionMock) ResetFooCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *FuncArgsCollisionMock) ResetCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// GetIntMock is a mock implementation of test.GetInt.
//
//	func TestSomethingThatUsesGetInt(t *testing.T) {
//
//		// make and configure a mocked test.GetInt
//		mockedGetInt := &GetIntMock{
//			GetFunc: func() int {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedGetInt in code that requires test.GetInt
//		// and then make assertions.
//
//	}
type GetIntMock struct {
	// GetFunc mocks the Get method.
	GetFunc func() int

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *GetIntMock) Get() int {
	if mock.GetFunc == nil {
		panic("GetIntMock.GetFunc: method is nil but GetInt.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedGetInt.GetCalls())
func (mock *GetIntMock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *GetIntMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *GetIntMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// GetGenericMock is a mock implementation of test.GetGeneric.
//
//	func TestSomethingThatUsesGetGeneric(t *testing.T) {
//
//		// make and configure a mocked test.GetGeneric
//		mockedGetGeneric := &GetGenericMock{
//			GetFunc: func() T {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedGetGeneric in code that requires test.GetGeneric
//		// and then make assertions.
//
//	}
type GetGenericMock[TParam constraints.Integer] struct {
	// GetFunc mocks the Get method.
	GetFunc func() T

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *GetGenericMock[TParam]) Get() T {
	if mock.GetFunc == nil {
		panic("GetGenericMock.GetFunc: method is nil but GetGeneric.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedGetGeneric.GetCalls())
func (mock *GetGenericMock[TParam]) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *GetGenericMock[TParam]) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *GetGenericMock[TParam]) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// EmbeddedGetMock is a mock implementation of test.EmbeddedGet.
//
//	func TestSomethingThatUsesEmbeddedGet(t *testing.T) {
//
//		// make and configure a mocked test.EmbeddedGet
//		mockedEmbeddedGet := &EmbeddedGetMock{
//			GetFunc: func() T {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedEmbeddedGet in code that requires test.EmbeddedGet
//		// and then make assertions.
//
//	}
type EmbeddedGetMock[TParam constraints.Signed] struct {
	// GetFunc mocks the Get method.
	GetFunc func() T

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *EmbeddedGetMock[TParam]) Get() T {
	if mock.GetFunc == nil {
		panic("EmbeddedGetMock.GetFunc: method is nil but EmbeddedGet.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedEmbeddedGet.GetCalls())
func (mock *EmbeddedGetMock[TParam]) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *EmbeddedGetMock[TParam]) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *EmbeddedGetMock[TParam]) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ReplaceGenericMock is a mock implementation of test.ReplaceGeneric.
//
//	func TestSomethingThatUsesReplaceGeneric(t *testing.T) {
//
//		// make and configure a mocked test.ReplaceGeneric
//		mockedReplaceGeneric := &ReplaceGenericMock{
//			AFunc: func(t1Param TImport) TKeep {
//				panic("mock out the A method")
//			},
//			BFunc: func() TImport {
//				panic("mock out the B method")
//			},
//			CFunc: func() TConstraint {
//				panic("mock out the C method")
//			},
//		}
//
//		// use mockedReplaceGeneric in code that requires test.ReplaceGeneric
//		// and then make assertions.
//
//	}
type ReplaceGenericMock[TImportParam any, TConstraintParam constraints.Signed, TKeepParam any] struct {
	// AFunc mocks the A method.
	AFunc func(t1Param TImport) TKeep

	// BFunc mocks the B method.
	BFunc func() TImport

	// CFunc mocks the C method.
	CFunc func() TConstraint

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
			// T1Param is the t1Param argument value.
			T1Param TImport
		}
		// B holds details about calls to the B method.
		B []struct {
		}
		// C holds details about calls to the C method.
		C []struct {
		}
	}
	lockA sync.RWMutex
	lockB sync.RWMutex
	lockC sync.RWMutex
}

// A calls AFunc.
func (mock *ReplaceGenericMock[TImportParam, TConstraintParam, TKeepParam]) A(t1Param TImport) TKeep {
	if mock.AFunc == nil {
		panic("ReplaceGenericMock.AFunc: method is nil but ReplaceGeneric.A was just called")
	}
	callInfo := struct {
		T1Param TImport
	}{
		T1Param: t1Param,
	}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	return mock.AFunc(t1Param)
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedReplaceGeneric.ACalls())
func (mock *ReplaceGenericMock[TImportParam, TConstraintParam, TKeepParam]) ACalls() []struct {
	T1Param TImport
} {
	var calls []struct {
		T1Param TImport
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *ReplaceGenericMock[TImportParam, TConstraintParam, TKeepParam]) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// B calls BFunc.
func (mock *ReplaceGenericMock[TImportParam, TConstraintParam, TKeepParam]) B() TImport {
	if mock.BFunc == nil {
		panic("ReplaceGenericMock.BFunc: method is nil but ReplaceGeneric.B was just called")
	}
	callInfo := struct {
	}{}
	mock.lockB.Lock()
	mock.calls.B = append(mock.calls.B, callInfo)
	mock.lockB.Unlock()
	return mock.BFunc()
}

// BCalls gets all the calls that were made to B.
// Check the length with:
//
//	len(mockedReplaceGeneric.BCalls())
func (mock *ReplaceGenericMock[TImportParam, TConstraintParam, TKeepParam]) BCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockB.RLock()
	calls = mock.calls.B
	mock.lockB.RUnlock()
	return calls
}

// ResetBCalls reset all the calls that were made to B.
func (mock *ReplaceGenericMock[TImportParam, TConstraintParam, TKeepParam]) ResetBCalls() {
	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()
}

// C calls CFunc.
func (mock *ReplaceGenericMock[TImportParam, TConstraintParam, TKeepParam]) C() TConstraint {
	if mock.CFunc == nil {
		panic("ReplaceGenericMock.CFunc: method is nil but ReplaceGeneric.C was just called")
	}
	callInfo := struct {
	}{}
	mock.lockC.Lock()
	mock.calls.C = append(mock.calls.C, callInfo)
	mock.lockC.Unlock()
	return mock.CFunc()
}

// CCalls gets all the calls that were made to C.
// Check the length with:
//
//	len(mockedReplaceGeneric.CCalls())
func (mock *ReplaceGenericMock[TImportParam, TConstraintParam, TKeepParam]) CCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockC.RLock()
	calls = mock.calls.C
	mock.lockC.RUnlock()
	return calls
}

// ResetCCalls reset all the calls that were made to C.
func (mock *ReplaceGenericMock[TImportParam, TConstraintParam, TKeepParam]) ResetCCalls() {
	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ReplaceGenericMock[TImportParam, TConstraintParam, TKeepParam]) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()

	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()

	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ReplaceGenericSelfMock is a mock implementation of test.ReplaceGenericSelf.
//
//	func TestSomethingThatUsesReplaceGenericSelf(t *testing.T) {
//
//		// make and configure a mocked test.ReplaceGenericSelf
//		mockedReplaceGenericSelf := &ReplaceGenericSelfMock{
//			AFunc: func() T {
//				panic("mock out the A method")
//			},
//		}
//
//		// use mockedReplaceGenericSelf in code that requires test.ReplaceGenericSelf
//		// and then make assertions.
//
//	}
type ReplaceGenericSelfMock[TParam any] struct {
	// AFunc mocks the A method.
	AFunc func() T

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
		}
	}
	lockA sync.RWMutex
}

// A calls AFunc.
func (mock *ReplaceGenericSelfMock[TParam]) A() T {
	if mock.AFunc == nil {
		panic("ReplaceGenericSelfMock.AFunc: method is nil but ReplaceGenericSelf.A was just called")
	}
	callInfo := struct {
	}{}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	return mock.AFunc()
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedReplaceGenericSelf.ACalls())
func (mock *ReplaceGenericSelfMock[TParam]) ACalls() []struct {
} {
	var calls []struct {
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *ReplaceGenericSelfMock[TParam]) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ReplaceGenericSelfMock[TParam]) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// HasConflictingNestedImportsMock is a mock implementation of test.HasConflictingNestedImports.
//
//	func TestSomethingThatUsesHasConflictingNestedImports(t *testing.T) {
//
//		// make and configure a mocked test.HasConflictingNestedImports
//		mockedHasConflictingNestedImports := &HasConflictingNestedImportsMock{
//			GetFunc: func(pathParam string) (http.Response, error) {
//				panic("mock out the Get method")
//			},
//			ZFunc: func() my_http.MyStruct {
//				panic("mock out the Z method")
//			},
//		}
//
//		// use mockedHasConflictingNestedImports in code that requires test.HasConflictingNestedImports
//		// and then make assertions.
//
//	}
type HasConflictingNestedImportsMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(pathParam string) (http.Response, error)

	// ZFunc mocks the Z method.
	ZFunc func() my_http.MyStruct

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// PathParam is the pathParam argument value.
			PathParam string
		}
		// Z holds details about calls to the Z method.
		Z []struct {
		}
	}
	lockGet sync.RWMutex
	lockZ   sync.RWMutex
}

// Get calls GetFunc.
func (mock *HasConflictingNestedImportsMock) Get(pathParam string) (http.Response, error) {
	if mock.GetFunc == nil {
		panic("HasConflictingNestedImportsMock.GetFunc: method is nil but HasConflictingNestedImports.Get was just called")
	}
	callInfo := struct {
		PathParam string
	}{
		PathParam: pathParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(pathParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedHasConflictingNestedImports.GetCalls())
func (mock *HasConflictingNestedImportsMock) GetCalls() []struct {
	PathParam string
} {
	var calls []struct {
		PathParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *HasConflictingNestedImportsMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Z calls ZFunc.
func (mock *HasConflictingNestedImportsMock) Z() my_http.MyStruct {
	if mock.ZFunc == nil {
		panic("HasConflictingNestedImportsMock.ZFunc: method is nil but HasConflictingNestedImports.Z was just called")
	}
	callInfo := struct {
	}{}
	mock.lockZ.Lock()
	mock.calls.Z = append(mock.calls.Z, callInfo)
	mock.lockZ.Unlock()
	return mock.ZFunc()
}

// ZCalls gets all the calls that were made to Z.
// Check the length with:
//
//	len(mockedHasConflictingNestedImports.ZCalls())
func (mock *HasConflictingNestedImportsMock) ZCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockZ.RLock()
	calls = mock.calls.Z
	mock.lockZ.RUnlock()
	return calls
}

// ResetZCalls reset all the calls that were made to Z.
func (mock *HasConflictingNestedImportsMock) ResetZCalls() {
	mock.lockZ.Lock()
	mock.calls.Z = nil
	mock.lockZ.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *HasConflictingNestedImportsMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockZ.Lock()
	mock.calls.Z = nil
	mock.lockZ.Unlock()
}

// ImportsSameAsPackageMock is a mock implementation of test.ImportsSameAsPackage.
//
//	func TestSomethingThatUsesImportsSameAsPackage(t *testing.T) {
//
//		// make and configure a mocked test.ImportsSameAsPackage
//		mockedImportsSameAsPackage := &ImportsSameAsPackageMock{
//			AFunc: func() redefinedtypeb.B {
//				panic("mock out the A method")
//			},
//			BFunc: func() fixtures.KeyManager {
//				panic("mock out the B method")
//			},
//			CFunc: func(cParam fixtures.C)  {
//				panic("mock out the C method")
//			},
//		}
//
//		// use mockedImportsSameAsPackage in code that requires test.ImportsSameAsPackage
//		// and then make assertions.
//
//	}
type ImportsSameAsPackageMock struct {
	// AFunc mocks the A method.
	AFunc func() redefinedtypeb.B

	// BFunc mocks the B method.
	BFunc func() fixtures.KeyManager

	// CFunc mocks the C method.
	CFunc func(cParam fixtures.C)

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
		}
		// B holds details about calls to the B method.
		B []struct {
		}
		// C holds details about calls to the C method.
		C []struct {
			// CParam is the cParam argument value.
			CParam fixtures.C
		}
	}
	lockA sync.RWMutex
	lockB sync.RWMutex
	lockC sync.RWMutex
}

// A calls AFunc.
func (mock *ImportsSameAsPackageMock) A() redefinedtypeb.B {
	if mock.AFunc == nil {
		panic("ImportsSameAsPackageMock.AFunc: method is nil but ImportsSameAsPackage.A was just called")
	}
	callInfo := struct {
	}{}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	return mock.AFunc()
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedImportsSameAsPackage.ACalls())
func (mock *ImportsSameAsPackageMock) ACalls() []struct {
} {
	var calls []struct {
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *ImportsSameAsPackageMock) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// B calls BFunc.
func (mock *ImportsSameAsPackageMock) B() fixtures.KeyManager {
	if mock.BFunc == nil {
		panic("ImportsSameAsPackageMock.BFunc: method is nil but ImportsSameAsPackage.B was just called")
	}
	callInfo := struct {
	}{}
	mock.lockB.Lock()
	mock.calls.B = append(mock.calls.B, callInfo)
	mock.lockB.Unlock()
	return mock.BFunc()
}

// BCalls gets all the calls that were made to B.
// Check the length with:
//
//	len(mockedImportsSameAsPackage.BCalls())
func (mock *ImportsSameAsPackageMock) BCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockB.RLock()
	calls = mock.calls.B
	mock.lockB.RUnlock()
	return calls
}

// ResetBCalls reset all the calls that were made to B.
func (mock *ImportsSameAsPackageMock) ResetBCalls() {
	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()
}

// C calls CFunc.
func (mock *ImportsSameAsPackageMock) C(cParam fixtures.C) {
	if mock.CFunc == nil {
		panic("ImportsSameAsPackageMock.CFunc: method is nil but ImportsSameAsPackage.C was just called")
	}
	callInfo := struct {
		CParam fixtures.C
	}{
		CParam: cParam,
	}
	mock.lockC.Lock()
	mock.calls.C = append(mock.calls.C, callInfo)
	mock.lockC.Unlock()
	mock.CFunc(cParam)
}

// CCalls gets all the calls that were made to C.
// Check the length with:
//
//	len(mockedImportsSameAsPackage.CCalls())
func (mock *ImportsSameAsPackageMock) CCalls() []struct {
	CParam fixtures.C
} {
	var calls []struct {
		CParam fixtures.C
	}
	mock.lockC.RLock()
	calls = mock.calls.C
	mock.lockC.RUnlock()
	return calls
}

// ResetCCalls reset all the calls that were made to C.
func (mock *ImportsSameAsPackageMock) ResetCCalls() {
	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ImportsSameAsPackageMock) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()

	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()

	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// GenericInterfaceMock is a mock implementation of test.GenericInterface.
//
//	func TestSomethingThatUsesGenericInterface(t *testing.T) {
//
//		// make and configure a mocked test.GenericInterface
//		mockedGenericInterface := &GenericInterfaceMock{
//			FuncFunc: func(argParam *M) int {
//				panic("mock out the Func method")
//			},
//		}
//
//		// use mockedGenericInterface in code that requires test.GenericInterface
//		// and then make assertions.
//
//	}
type GenericInterfaceMock[MParam any] struct {
	// FuncFunc mocks the Func method.
	FuncFunc func(argParam *M) int

	// calls tracks calls to the methods.
	calls struct {
		// Func holds details about calls to the Func method.
		Func []struct {
			// ArgParam is the argParam argument value.
			ArgParam *M
		}
	}
	lockFunc sync.RWMutex
}

// Func calls FuncFunc.
func (mock *GenericInterfaceMock[MParam]) Func(argParam *M) int {
	if mock.FuncFunc == nil {
		panic("GenericInterfaceMock.FuncFunc: method is nil but GenericInterface.Func was just called")
	}
	callInfo := struct {
		ArgParam *M
	}{
		ArgParam: argParam,
	}
	mock.lockFunc.Lock()
	mock.calls.Func = append(mock.calls.Func, callInfo)
	mock.lockFunc.Unlock()
	return mock.FuncFunc(argParam)
}

// FuncCalls gets all the calls that were made to Func.
// Check the length with:
//
//	len(mockedGenericInterface.FuncCalls())
func (mock *GenericInterfaceMock[MParam]) FuncCalls() []struct {
	ArgParam *M
} {
	var calls []struct {
		ArgParam *M
	}
	mock.lockFunc.RLock()
	calls = mock.calls.Func
	mock.lockFunc.RUnlock()
	return calls
}

// ResetFuncCalls reset all the calls that were made to Func.
func (mock *GenericInterfaceMock[MParam]) ResetFuncCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *GenericInterfaceMock[MParam]) ResetCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// InstantiatedGenericInterfaceMock is a mock implementation of test.InstantiatedGenericInterface.
//
//	func TestSomethingThatUsesInstantiatedGenericInterface(t *testing.T) {
//
//		// make and configure a mocked test.InstantiatedGenericInterface
//		mockedInstantiatedGenericInterface := &InstantiatedGenericInterfaceMock{
//			FuncFunc: func(argParam *float32) int {
//				panic("mock out the Func method")
//			},
//		}
//
//		// use mockedInstantiatedGenericInterface in code that requires test.InstantiatedGenericInterface
//		// and then make assertions.
//
//	}
type InstantiatedGenericInterfaceMock struct {
	// FuncFunc mocks the Func method.
	FuncFunc func(argParam *float32) int

	// calls tracks calls to the methods.
	calls struct {
		// Func holds details about calls to the Func method.
		Func []struct {
			// ArgParam is the argParam argument value.
			ArgParam *float32
		}
	}
	lockFunc sync.RWMutex
}

// Func calls FuncFunc.
func (mock *InstantiatedGenericInterfaceMock) Func(argParam *float32) int {
	if mock.FuncFunc == nil {
		panic("InstantiatedGenericInterfaceMock.FuncFunc: method is nil but InstantiatedGenericInterface.Func was just called")
	}
	callInfo := struct {
		ArgParam *float32
	}{
		ArgParam: argParam,
	}
	mock.lockFunc.Lock()
	mock.calls.Func = append(mock.calls.Func, callInfo)
	mock.lockFunc.Unlock()
	return mock.FuncFunc(argParam)
}

// FuncCalls gets all the calls that were made to Func.
// Check the length with:
//
//	len(mockedInstantiatedGenericInterface.FuncCalls())
func (mock *InstantiatedGenericInterfaceMock) FuncCalls() []struct {
	ArgParam *float32
} {
	var calls []struct {
		ArgParam *float32
	}
	mock.lockFunc.RLock()
	calls = mock.calls.Func
	mock.lockFunc.RUnlock()
	return calls
}

// ResetFuncCalls reset all the calls that were made to Func.
func (mock *InstantiatedGenericInterfaceMock) ResetFuncCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *InstantiatedGenericInterfaceMock) ResetCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// MyReaderMock is a mock implementation of test.MyReader.
//
//	func TestSomethingThatUsesMyReader(t *testing.T) {
//
//		// make and configure a mocked test.MyReader
//		mockedMyReader := &MyReaderMock{
//			ReadFunc: func(pParam []byte) (int, error) {
//				panic("mock out the Read method")
//			},
//		}
//
//		// use mockedMyReader in code that requires test.MyReader
//		// and then make assertions.
//
//	}
type MyReaderMock struct {
	// ReadFunc mocks the Read method.
	ReadFunc func(pParam []byte) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Read holds details about calls to the Read method.
		Read []struct {
			// PParam is the pParam argument value.
			PParam []byte
		}
	}
	lockRead sync.RWMutex
}

// Read calls ReadFunc.
func (mock *MyReaderMock) Read(pParam []byte) (int, error) {
	if mock.ReadFunc == nil {
		panic("MyReaderMock.ReadFunc: method is nil but MyReader.Read was just called")
	}
	callInfo := struct {
		PParam []byte
	}{
		PParam: pParam,
	}
	mock.lockRead.Lock()
	mock.calls.Read = append(mock.calls.Read, callInfo)
	mock.lockRead.Unlock()
	return mock.ReadFunc(pParam)
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//	len(mockedMyReader.ReadCalls())
func (mock *MyReaderMock) ReadCalls() []struct {
	PParam []byte
} {
	var calls []struct {
		PParam []byte
	}
	mock.lockRead.RLock()
	calls = mock.calls.Read
	mock.lockRead.RUnlock()
	return calls
}

// ResetReadCalls reset all the calls that were made to Read.
func (mock *MyReaderMock) ResetReadCalls() {
	mock.lockRead.Lock()
	mock.calls.Read = nil
	mock.lockRead.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MyReaderMock) ResetCalls() {
	mock.lockRead.Lock()
	mock.calls.Read = nil
	mock.lockRead.Unlock()
}

// Issue766Mock is a mock implementation of test.Issue766.
//
//	func TestSomethingThatUsesIssue766(t *testing.T) {
//
//		// make and configure a mocked test.Issue766
//		mockedIssue766 := &Issue766Mock{
//			FetchDataFunc: func(fetchFuncParam func(x ...int) ([]int, error)) ([]int, error) {
//				panic("mock out the FetchData method")
//			},
//		}
//
//		// use mockedIssue766 in code that requires test.Issue766
//		// and then make assertions.
//
//	}
type Issue766Mock struct {
	// FetchDataFunc mocks the FetchData method.
	FetchDataFunc func(fetchFuncParam func(x ...int) ([]int, error)) ([]int, error)

	// calls tracks calls to the methods.
	calls struct {
		// FetchData holds details about calls to the FetchData method.
		FetchData []struct {
			// FetchFuncParam is the fetchFuncParam argument value.
			FetchFuncParam func(x ...int) ([]int, error)
		}
	}
	lockFetchData sync.RWMutex
}

// FetchData calls FetchDataFunc.
func (mock *Issue766Mock) FetchData(fetchFuncParam func(x ...int) ([]int, error)) ([]int, error) {
	if mock.FetchDataFunc == nil {
		panic("Issue766Mock.FetchDataFunc: method is nil but Issue766.FetchData was just called")
	}
	callInfo := struct {
		FetchFuncParam func(x ...int) ([]int, error)
	}{
		FetchFuncParam: fetchFuncParam,
	}
	mock.lockFetchData.Lock()
	mock.calls.FetchData = append(mock.calls.FetchData, callInfo)
	mock.lockFetchData.Unlock()
	return mock.FetchDataFunc(fetchFuncParam)
}

// FetchDataCalls gets all the calls that were made to FetchData.
// Check the length with:
//
//	len(mockedIssue766.FetchDataCalls())
func (mock *Issue766Mock) FetchDataCalls() []struct {
	FetchFuncParam func(x ...int) ([]int, error)
} {
	var calls []struct {
		FetchFuncParam func(x ...int) ([]int, error)
	}
	mock.lockFetchData.RLock()
	calls = mock.calls.FetchData
	mock.lockFetchData.RUnlock()
	return calls
}

// ResetFetchDataCalls reset all the calls that were made to FetchData.
func (mock *Issue766Mock) ResetFetchDataCalls() {
	mock.lockFetchData.Lock()
	mock.calls.FetchData = nil
	mock.lockFetchData.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *Issue766Mock) ResetCalls() {
	mock.lockFetchData.Lock()
	mock.calls.FetchData = nil
	mock.lockFetchData.Unlock()
}

// MapToInterfaceMock is a mock implementation of test.MapToInterface.
//
//	func TestSomethingThatUsesMapToInterface(t *testing.T) {
//
//		// make and configure a mocked test.MapToInterface
//		mockedMapToInterface := &MapToInterfaceMock{
//			FooFunc: func(arg1Param ...map[string]interface{})  {
//				panic("mock out the Foo method")
//			},
//		}
//
//		// use mockedMapToInterface in code that requires test.MapToInterface
//		// and then make assertions.
//
//	}
type MapToInterfaceMock struct {
	// FooFunc mocks the Foo method.
	FooFunc func(arg1Param ...map[string]interface{})

	// calls tracks calls to the methods.
	calls struct {
		// Foo holds details about calls to the Foo method.
		Foo []struct {
			// Arg1Param is the arg1Param argument value.
			Arg1Param []map[string]interface{}
		}
	}
	lockFoo sync.RWMutex
}

// Foo calls FooFunc.
func (mock *MapToInterfaceMock) Foo(arg1Param ...map[string]interface{}) {
	if mock.FooFunc == nil {
		panic("MapToInterfaceMock.FooFunc: method is nil but MapToInterface.Foo was just called")
	}
	callInfo := struct {
		Arg1Param []map[string]interface{}
	}{
		Arg1Param: arg1Param,
	}
	mock.lockFoo.Lock()
	mock.calls.Foo = append(mock.calls.Foo, callInfo)
	mock.lockFoo.Unlock()
	mock.FooFunc(arg1Param...)
}

// FooCalls gets all the calls that were made to Foo.
// Check the length with:
//
//	len(mockedMapToInterface.FooCalls())
func (mock *MapToInterfaceMock) FooCalls() []struct {
	Arg1Param []map[string]interface{}
} {
	var calls []struct {
		Arg1Param []map[string]interface{}
	}
	mock.lockFoo.RLock()
	calls = mock.calls.Foo
	mock.lockFoo.RUnlock()
	return calls
}

// ResetFooCalls reset all the calls that were made to Foo.
func (mock *MapToInterfaceMock) ResetFooCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MapToInterfaceMock) ResetCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// SiblingMock is a mock implementation of test.Sibling.
//
//	func TestSomethingThatUsesSibling(t *testing.T) {
//
//		// make and configure a mocked test.Sibling
//		mockedSibling := &SiblingMock{
//			DoSomethingFunc: func()  {
//				panic("mock out the DoSomething method")
//			},
//		}
//
//		// use mockedSibling in code that requires test.Sibling
//		// and then make assertions.
//
//	}
type SiblingMock struct {
	// DoSomethingFunc mocks the DoSomething method.
	DoSomethingFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// DoSomething holds details about calls to the DoSomething method.
		DoSomething []struct {
		}
	}
	lockDoSomething sync.RWMutex
}

// DoSomething calls DoSomethingFunc.
func (mock *SiblingMock) DoSomething() {
	if mock.DoSomethingFunc == nil {
		panic("SiblingMock.DoSomethingFunc: method is nil but Sibling.DoSomething was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = append(mock.calls.DoSomething, callInfo)
	mock.lockDoSomething.Unlock()
	mock.DoSomethingFunc()
}

// DoSomethingCalls gets all the calls that were made to DoSomething.
// Check the length with:
//
//	len(mockedSibling.DoSomethingCalls())
func (mock *SiblingMock) DoSomethingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDoSomething.RLock()
	calls = mock.calls.DoSomething
	mock.lockDoSomething.RUnlock()
	return calls
}

// ResetDoSomethingCalls reset all the calls that were made to DoSomething.
func (mock *SiblingMock) ResetDoSomethingCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SiblingMock) ResetCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// UsesOtherPkgIfaceMock is a mock implementation of test.UsesOtherPkgIface.
//
//	func TestSomethingThatUsesUsesOtherPkgIface(t *testing.T) {
//
//		// make and configure a mocked test.UsesOtherPkgIface
//		mockedUsesOtherPkgIface := &UsesOtherPkgIfaceMock{
//			DoSomethingElseFunc: func(objParam fixtures.Sibling)  {
//				panic("mock out the DoSomethingElse method")
//			},
//		}
//
//		// use mockedUsesOtherPkgIface in code that requires test.UsesOtherPkgIface
//		// and then make assertions.
//
//	}
type UsesOtherPkgIfaceMock struct {
	// DoSomethingElseFunc mocks the DoSomethingElse method.
	DoSomethingElseFunc func(objParam fixtures.Sibling)

	// calls tracks calls to the methods.
	calls struct {
		// DoSomethingElse holds details about calls to the DoSomethingElse method.
		DoSomethingElse []struct {
			// ObjParam is the objParam argument value.
			ObjParam fixtures.Sibling
		}
	}
	lockDoSomethingElse sync.RWMutex
}

// DoSomethingElse calls DoSomethingElseFunc.
func (mock *UsesOtherPkgIfaceMock) DoSomethingElse(objParam fixtures.Sibling) {
	if mock.DoSomethingElseFunc == nil {
		panic("UsesOtherPkgIfaceMock.DoSomethingElseFunc: method is nil but UsesOtherPkgIface.DoSomethingElse was just called")
	}
	callInfo := struct {
		ObjParam fixtures.Sibling
	}{
		ObjParam: objParam,
	}
	mock.lockDoSomethingElse.Lock()
	mock.calls.DoSomethingElse = append(mock.calls.DoSomethingElse, callInfo)
	mock.lockDoSomethingElse.Unlock()
	mock.DoSomethingElseFunc(objParam)
}

// DoSomethingElseCalls gets all the calls that were made to DoSomethingElse.
// Check the length with:
//
//	len(mockedUsesOtherPkgIface.DoSomethingElseCalls())
func (mock *UsesOtherPkgIfaceMock) DoSomethingElseCalls() []struct {
	ObjParam fixtures.Sibling
} {
	var calls []struct {
		ObjParam fixtures.Sibling
	}
	mock.lockDoSomethingElse.RLock()
	calls = mock.calls.DoSomethingElse
	mock.lockDoSomethingElse.RUnlock()
	return calls
}

// ResetDoSomethingElseCalls reset all the calls that were made to DoSomethingElse.
func (mock *UsesOtherPkgIfaceMock) ResetDoSomethingElseCalls() {
	mock.lockDoSomethingElse.Lock()
	mock.calls.DoSomethingElse = nil
	mock.lockDoSomethingElse.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *UsesOtherPkgIfaceMock) ResetCalls() {
	mock.lockDoSomethingElse.Lock()
	mock.calls.DoSomethingElse = nil
	mock.lockDoSomethingElse.Unlock()
}

// PanicOnNoReturnValueMock is a mock implementation of test.PanicOnNoReturnValue.
//
//	func TestSomethingThatUsesPanicOnNoReturnValue(t *testing.T) {
//
//		// make and configure a mocked test.PanicOnNoReturnValue
//		mockedPanicOnNoReturnValue := &PanicOnNoReturnValueMock{
//			DoSomethingFunc: func() string {
//				panic("mock out the DoSomething method")
//			},
//		}
//
//		// use mockedPanicOnNoReturnValue in code that requires test.PanicOnNoReturnValue
//		// and then make assertions.
//
//	}
type PanicOnNoReturnValueMock struct {
	// DoSomethingFunc mocks the DoSomething method.
	DoSomethingFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// DoSomething holds details about calls to the DoSomething method.
		DoSomething []struct {
		}
	}
	lockDoSomething sync.RWMutex
}

// DoSomething calls DoSomethingFunc.
func (mock *PanicOnNoReturnValueMock) DoSomething() string {
	if mock.DoSomethingFunc == nil {
		panic("PanicOnNoReturnValueMock.DoSomethingFunc: method is nil but PanicOnNoReturnValue.DoSomething was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = append(mock.calls.DoSomething, callInfo)
	mock.lockDoSomething.Unlock()
	return mock.DoSomethingFunc()
}

// DoSomethingCalls gets all the calls that were made to DoSomething.
// Check the length with:
//
//	len(mockedPanicOnNoReturnValue.DoSomethingCalls())
func (mock *PanicOnNoReturnValueMock) DoSomethingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDoSomething.RLock()
	calls = mock.calls.DoSomething
	mock.lockDoSomething.RUnlock()
	return calls
}

// ResetDoSomethingCalls reset all the calls that were made to DoSomething.
func (mock *PanicOnNoReturnValueMock) ResetDoSomethingCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *PanicOnNoReturnValueMock) ResetCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// RequesterMock is a mock implementation of test.Requester.
//
//	func TestSomethingThatUsesRequester(t *testing.T) {
//
//		// make and configure a mocked test.Requester
//		mockedRequester := &RequesterMock{
//			GetFunc: func(pathParam string) (string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester in code that requires test.Requester
//		// and then make assertions.
//
//	}
type RequesterMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(pathParam string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// PathParam is the pathParam argument value.
			PathParam string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterMock) Get(pathParam string) (string, error) {
	if mock.GetFunc == nil {
		panic("RequesterMock.GetFunc: method is nil but Requester.Get was just called")
	}
	callInfo := struct {
		PathParam string
	}{
		PathParam: pathParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(pathParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester.GetCalls())
func (mock *RequesterMock) GetCalls() []struct {
	PathParam string
} {
	var calls []struct {
		PathParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Requester2Mock is a mock implementation of test.Requester2.
//
//	func TestSomethingThatUsesRequester2(t *testing.T) {
//
//		// make and configure a mocked test.Requester2
//		mockedRequester2 := &Requester2Mock{
//			GetFunc: func(pathParam string) error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester2 in code that requires test.Requester2
//		// and then make assertions.
//
//	}
type Requester2Mock struct {
	// GetFunc mocks the Get method.
	GetFunc func(pathParam string) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// PathParam is the pathParam argument value.
			PathParam string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *Requester2Mock) Get(pathParam string) error {
	if mock.GetFunc == nil {
		panic("Requester2Mock.GetFunc: method is nil but Requester2.Get was just called")
	}
	callInfo := struct {
		PathParam string
	}{
		PathParam: pathParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(pathParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester2.GetCalls())
func (mock *Requester2Mock) GetCalls() []struct {
	PathParam string
} {
	var calls []struct {
		PathParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *Requester2Mock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *Requester2Mock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Requester3Mock is a mock implementation of test.Requester3.
//
//	func TestSomethingThatUsesRequester3(t *testing.T) {
//
//		// make and configure a mocked test.Requester3
//		mockedRequester3 := &Requester3Mock{
//			GetFunc: func() error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester3 in code that requires test.Requester3
//		// and then make assertions.
//
//	}
type Requester3Mock struct {
	// GetFunc mocks the Get method.
	GetFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *Requester3Mock) Get() error {
	if mock.GetFunc == nil {
		panic("Requester3Mock.GetFunc: method is nil but Requester3.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester3.GetCalls())
func (mock *Requester3Mock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *Requester3Mock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *Requester3Mock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Requester4Mock is a mock implementation of test.Requester4.
//
//	func TestSomethingThatUsesRequester4(t *testing.T) {
//
//		// make and configure a mocked test.Requester4
//		mockedRequester4 := &Requester4Mock{
//			GetFunc: func()  {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester4 in code that requires test.Requester4
//		// and then make assertions.
//
//	}
type Requester4Mock struct {
	// GetFunc mocks the Get method.
	GetFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *Requester4Mock) Get() {
	if mock.GetFunc == nil {
		panic("Requester4Mock.GetFunc: method is nil but Requester4.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester4.GetCalls())
func (mock *Requester4Mock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *Requester4Mock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *Requester4Mock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterArgSameAsImportMock is a mock implementation of test.RequesterArgSameAsImport.
//
//	func TestSomethingThatUsesRequesterArgSameAsImport(t *testing.T) {
//
//		// make and configure a mocked test.RequesterArgSameAsImport
//		mockedRequesterArgSameAsImport := &RequesterArgSameAsImportMock{
//			GetFunc: func(jsonParam string) *json.RawMessage {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArgSameAsImport in code that requires test.RequesterArgSameAsImport
//		// and then make assertions.
//
//	}
type RequesterArgSameAsImportMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(jsonParam string) *json.RawMessage

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// JsonParam is the jsonParam argument value.
			JsonParam string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterArgSameAsImportMock) Get(jsonParam string) *json.RawMessage {
	if mock.GetFunc == nil {
		panic("RequesterArgSameAsImportMock.GetFunc: method is nil but RequesterArgSameAsImport.Get was just called")
	}
	callInfo := struct {
		JsonParam string
	}{
		JsonParam: jsonParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(jsonParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArgSameAsImport.GetCalls())
func (mock *RequesterArgSameAsImportMock) GetCalls() []struct {
	JsonParam string
} {
	var calls []struct {
		JsonParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterArgSameAsImportMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterArgSameAsImportMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterArgSameAsNamedImportMock is a mock implementation of test.RequesterArgSameAsNamedImport.
//
//	func TestSomethingThatUsesRequesterArgSameAsNamedImport(t *testing.T) {
//
//		// make and configure a mocked test.RequesterArgSameAsNamedImport
//		mockedRequesterArgSameAsNamedImport := &RequesterArgSameAsNamedImportMock{
//			GetFunc: func(jsonParam string) *json.RawMessage {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArgSameAsNamedImport in code that requires test.RequesterArgSameAsNamedImport
//		// and then make assertions.
//
//	}
type RequesterArgSameAsNamedImportMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(jsonParam string) *json.RawMessage

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// JsonParam is the jsonParam argument value.
			JsonParam string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterArgSameAsNamedImportMock) Get(jsonParam string) *json.RawMessage {
	if mock.GetFunc == nil {
		panic("RequesterArgSameAsNamedImportMock.GetFunc: method is nil but RequesterArgSameAsNamedImport.Get was just called")
	}
	callInfo := struct {
		JsonParam string
	}{
		JsonParam: jsonParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(jsonParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArgSameAsNamedImport.GetCalls())
func (mock *RequesterArgSameAsNamedImportMock) GetCalls() []struct {
	JsonParam string
} {
	var calls []struct {
		JsonParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterArgSameAsNamedImportMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterArgSameAsNamedImportMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterArgSameAsPkgMock is a mock implementation of test.RequesterArgSameAsPkg.
//
//	func TestSomethingThatUsesRequesterArgSameAsPkg(t *testing.T) {
//
//		// make and configure a mocked test.RequesterArgSameAsPkg
//		mockedRequesterArgSameAsPkg := &RequesterArgSameAsPkgMock{
//			GetFunc: func(testParam string)  {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArgSameAsPkg in code that requires test.RequesterArgSameAsPkg
//		// and then make assertions.
//
//	}
type RequesterArgSameAsPkgMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(testParam string)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// TestParam is the testParam argument value.
			TestParam string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterArgSameAsPkgMock) Get(testParam string) {
	if mock.GetFunc == nil {
		panic("RequesterArgSameAsPkgMock.GetFunc: method is nil but RequesterArgSameAsPkg.Get was just called")
	}
	callInfo := struct {
		TestParam string
	}{
		TestParam: testParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	mock.GetFunc(testParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArgSameAsPkg.GetCalls())
func (mock *RequesterArgSameAsPkgMock) GetCalls() []struct {
	TestParam string
} {
	var calls []struct {
		TestParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterArgSameAsPkgMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterArgSameAsPkgMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterArrayMock is a mock implementation of test.RequesterArray.
//
//	func TestSomethingThatUsesRequesterArray(t *testing.T) {
//
//		// make and configure a mocked test.RequesterArray
//		mockedRequesterArray := &RequesterArrayMock{
//			GetFunc: func(pathParam string) ([2]string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArray in code that requires test.RequesterArray
//		// and then make assertions.
//
//	}
type RequesterArrayMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(pathParam string) ([2]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// PathParam is the pathParam argument value.
			PathParam string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterArrayMock) Get(pathParam string) ([2]string, error) {
	if mock.GetFunc == nil {
		panic("RequesterArrayMock.GetFunc: method is nil but RequesterArray.Get was just called")
	}
	callInfo := struct {
		PathParam string
	}{
		PathParam: pathParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(pathParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArray.GetCalls())
func (mock *RequesterArrayMock) GetCalls() []struct {
	PathParam string
} {
	var calls []struct {
		PathParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterArrayMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterArrayMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterElidedMock is a mock implementation of test.RequesterElided.
//
//	func TestSomethingThatUsesRequesterElided(t *testing.T) {
//
//		// make and configure a mocked test.RequesterElided
//		mockedRequesterElided := &RequesterElidedMock{
//			GetFunc: func(pathParam string, urlParam string) error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterElided in code that requires test.RequesterElided
//		// and then make assertions.
//
//	}
type RequesterElidedMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(pathParam string, urlParam string) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// PathParam is the pathParam argument value.
			PathParam string
			// UrlParam is the urlParam argument value.
			UrlParam string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterElidedMock) Get(pathParam string, urlParam string) error {
	if mock.GetFunc == nil {
		panic("RequesterElidedMock.GetFunc: method is nil but RequesterElided.Get was just called")
	}
	callInfo := struct {
		PathParam string
		UrlParam  string
	}{
		PathParam: pathParam,
		UrlParam:  urlParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(pathParam, urlParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterElided.GetCalls())
func (mock *RequesterElidedMock) GetCalls() []struct {
	PathParam string
	UrlParam  string
} {
	var calls []struct {
		PathParam string
		UrlParam  string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterElidedMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterElidedMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterIfaceMock is a mock implementation of test.RequesterIface.
//
//	func TestSomethingThatUsesRequesterIface(t *testing.T) {
//
//		// make and configure a mocked test.RequesterIface
//		mockedRequesterIface := &RequesterIfaceMock{
//			GetFunc: func() io.Reader {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterIface in code that requires test.RequesterIface
//		// and then make assertions.
//
//	}
type RequesterIfaceMock struct {
	// GetFunc mocks the Get method.
	GetFunc func() io.Reader

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterIfaceMock) Get() io.Reader {
	if mock.GetFunc == nil {
		panic("RequesterIfaceMock.GetFunc: method is nil but RequesterIface.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterIface.GetCalls())
func (mock *RequesterIfaceMock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterIfaceMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterIfaceMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterNSMock is a mock implementation of test.RequesterNS.
//
//	func TestSomethingThatUsesRequesterNS(t *testing.T) {
//
//		// make and configure a mocked test.RequesterNS
//		mockedRequesterNS := &RequesterNSMock{
//			GetFunc: func(pathParam string) (http.Response, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterNS in code that requires test.RequesterNS
//		// and then make assertions.
//
//	}
type RequesterNSMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(pathParam string) (http.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// PathParam is the pathParam argument value.
			PathParam string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterNSMock) Get(pathParam string) (http.Response, error) {
	if mock.GetFunc == nil {
		panic("RequesterNSMock.GetFunc: method is nil but RequesterNS.Get was just called")
	}
	callInfo := struct {
		PathParam string
	}{
		PathParam: pathParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(pathParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterNS.GetCalls())
func (mock *RequesterNSMock) GetCalls() []struct {
	PathParam string
} {
	var calls []struct {
		PathParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterNSMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterNSMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterPtrMock is a mock implementation of test.RequesterPtr.
//
//	func TestSomethingThatUsesRequesterPtr(t *testing.T) {
//
//		// make and configure a mocked test.RequesterPtr
//		mockedRequesterPtr := &RequesterPtrMock{
//			GetFunc: func(pathParam string) (*string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterPtr in code that requires test.RequesterPtr
//		// and then make assertions.
//
//	}
type RequesterPtrMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(pathParam string) (*string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// PathParam is the pathParam argument value.
			PathParam string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterPtrMock) Get(pathParam string) (*string, error) {
	if mock.GetFunc == nil {
		panic("RequesterPtrMock.GetFunc: method is nil but RequesterPtr.Get was just called")
	}
	callInfo := struct {
		PathParam string
	}{
		PathParam: pathParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(pathParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterPtr.GetCalls())
func (mock *RequesterPtrMock) GetCalls() []struct {
	PathParam string
} {
	var calls []struct {
		PathParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterPtrMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterPtrMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterReturnElidedMock is a mock implementation of test.RequesterReturnElided.
//
//	func TestSomethingThatUsesRequesterReturnElided(t *testing.T) {
//
//		// make and configure a mocked test.RequesterReturnElided
//		mockedRequesterReturnElided := &RequesterReturnElidedMock{
//			GetFunc: func(pathParam string) (int, int, int, error) {
//				panic("mock out the Get method")
//			},
//			PutFunc: func(pathParam string) (int, error) {
//				panic("mock out the Put method")
//			},
//		}
//
//		// use mockedRequesterReturnElided in code that requires test.RequesterReturnElided
//		// and then make assertions.
//
//	}
type RequesterReturnElidedMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(pathParam string) (int, int, int, error)

	// PutFunc mocks the Put method.
	PutFunc func(pathParam string) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// PathParam is the pathParam argument value.
			PathParam string
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// PathParam is the pathParam argument value.
			PathParam string
		}
	}
	lockGet sync.RWMutex
	lockPut sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterReturnElidedMock) Get(pathParam string) (int, int, int, error) {
	if mock.GetFunc == nil {
		panic("RequesterReturnElidedMock.GetFunc: method is nil but RequesterReturnElided.Get was just called")
	}
	callInfo := struct {
		PathParam string
	}{
		PathParam: pathParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(pathParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterReturnElided.GetCalls())
func (mock *RequesterReturnElidedMock) GetCalls() []struct {
	PathParam string
} {
	var calls []struct {
		PathParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterReturnElidedMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Put calls PutFunc.
func (mock *RequesterReturnElidedMock) Put(pathParam string) (int, error) {
	if mock.PutFunc == nil {
		panic("RequesterReturnElidedMock.PutFunc: method is nil but RequesterReturnElided.Put was just called")
	}
	callInfo := struct {
		PathParam string
	}{
		PathParam: pathParam,
	}
	mock.lockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	mock.lockPut.Unlock()
	return mock.PutFunc(pathParam)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//
//	len(mockedRequesterReturnElided.PutCalls())
func (mock *RequesterReturnElidedMock) PutCalls() []struct {
	PathParam string
} {
	var calls []struct {
		PathParam string
	}
	mock.lockPut.RLock()
	calls = mock.calls.Put
	mock.lockPut.RUnlock()
	return calls
}

// ResetPutCalls reset all the calls that were made to Put.
func (mock *RequesterReturnElidedMock) ResetPutCalls() {
	mock.lockPut.Lock()
	mock.calls.Put = nil
	mock.lockPut.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterReturnElidedMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockPut.Lock()
	mock.calls.Put = nil
	mock.lockPut.Unlock()
}

// RequesterSliceMock is a mock implementation of test.RequesterSlice.
//
//	func TestSomethingThatUsesRequesterSlice(t *testing.T) {
//
//		// make and configure a mocked test.RequesterSlice
//		mockedRequesterSlice := &RequesterSliceMock{
//			GetFunc: func(pathParam string) ([]string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterSlice in code that requires test.RequesterSlice
//		// and then make assertions.
//
//	}
type RequesterSliceMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(pathParam string) ([]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// PathParam is the pathParam argument value.
			PathParam string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterSliceMock) Get(pathParam string) ([]string, error) {
	if mock.GetFunc == nil {
		panic("RequesterSliceMock.GetFunc: method is nil but RequesterSlice.Get was just called")
	}
	callInfo := struct {
		PathParam string
	}{
		PathParam: pathParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(pathParam)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterSlice.GetCalls())
func (mock *RequesterSliceMock) GetCalls() []struct {
	PathParam string
} {
	var calls []struct {
		PathParam string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterSliceMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterSliceMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// requesterUnexportedMock is a mock implementation of test.requesterUnexported.
//
//	func TestSomethingThatUsesrequesterUnexported(t *testing.T) {
//
//		// make and configure a mocked test.requesterUnexported
//		mockedrequesterUnexported := &requesterUnexportedMock{
//			GetFunc: func()  {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedrequesterUnexported in code that requires test.requesterUnexported
//		// and then make assertions.
//
//	}
type requesterUnexportedMock struct {
	// GetFunc mocks the Get method.
	GetFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *requesterUnexportedMock) Get() {
	if mock.GetFunc == nil {
		panic("requesterUnexportedMock.GetFunc: method is nil but requesterUnexported.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedrequesterUnexported.GetCalls())
func (mock *requesterUnexportedMock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *requesterUnexportedMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *requesterUnexportedMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterVariadicMock is a mock implementation of test.RequesterVariadic.
//
//	func TestSomethingThatUsesRequesterVariadic(t *testing.T) {
//
//		// make and configure a mocked test.RequesterVariadic
//		mockedRequesterVariadic := &RequesterVariadicMock{
//			GetFunc: func(valuesParam ...string) bool {
//				panic("mock out the Get method")
//			},
//			MultiWriteToFileFunc: func(filenameParam string, wParam ...io.Writer) string {
//				panic("mock out the MultiWriteToFile method")
//			},
//			OneInterfaceFunc: func(aParam ...interface{}) bool {
//				panic("mock out the OneInterface method")
//			},
//			SprintfFunc: func(formatParam string, aParam ...interface{}) string {
//				panic("mock out the Sprintf method")
//			},
//		}
//
//		// use mockedRequesterVariadic in code that requires test.RequesterVariadic
//		// and then make assertions.
//
//	}
type RequesterVariadicMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(valuesParam ...string) bool

	// MultiWriteToFileFunc mocks the MultiWriteToFile method.
	MultiWriteToFileFunc func(filenameParam string, wParam ...io.Writer) string

	// OneInterfaceFunc mocks the OneInterface method.
	OneInterfaceFunc func(aParam ...interface{}) bool

	// SprintfFunc mocks the Sprintf method.
	SprintfFunc func(formatParam string, aParam ...interface{}) string

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// ValuesParam is the valuesParam argument value.
			ValuesParam []string
		}
		// MultiWriteToFile holds details about calls to the MultiWriteToFile method.
		MultiWriteToFile []struct {
			// FilenameParam is the filenameParam argument value.
			FilenameParam string
			// WParam is the wParam argument value.
			WParam []io.Writer
		}
		// OneInterface holds details about calls to the OneInterface method.
		OneInterface []struct {
			// AParam is the aParam argument value.
			AParam []interface{}
		}
		// Sprintf holds details about calls to the Sprintf method.
		Sprintf []struct {
			// FormatParam is the formatParam argument value.
			FormatParam string
			// AParam is the aParam argument value.
			AParam []interface{}
		}
	}
	lockGet              sync.RWMutex
	lockMultiWriteToFile sync.RWMutex
	lockOneInterface     sync.RWMutex
	lockSprintf          sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterVariadicMock) Get(valuesParam ...string) bool {
	if mock.GetFunc == nil {
		panic("RequesterVariadicMock.GetFunc: method is nil but RequesterVariadic.Get was just called")
	}
	callInfo := struct {
		ValuesParam []string
	}{
		ValuesParam: valuesParam,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(valuesParam...)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterVariadic.GetCalls())
func (mock *RequesterVariadicMock) GetCalls() []struct {
	ValuesParam []string
} {
	var calls []struct {
		ValuesParam []string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterVariadicMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// MultiWriteToFile calls MultiWriteToFileFunc.
func (mock *RequesterVariadicMock) MultiWriteToFile(filenameParam string, wParam ...io.Writer) string {
	if mock.MultiWriteToFileFunc == nil {
		panic("RequesterVariadicMock.MultiWriteToFileFunc: method is nil but RequesterVariadic.MultiWriteToFile was just called")
	}
	callInfo := struct {
		FilenameParam string
		WParam        []io.Writer
	}{
		FilenameParam: filenameParam,
		WParam:        wParam,
	}
	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = append(mock.calls.MultiWriteToFile, callInfo)
	mock.lockMultiWriteToFile.Unlock()
	return mock.MultiWriteToFileFunc(filenameParam, wParam...)
}

// MultiWriteToFileCalls gets all the calls that were made to MultiWriteToFile.
// Check the length with:
//
//	len(mockedRequesterVariadic.MultiWriteToFileCalls())
func (mock *RequesterVariadicMock) MultiWriteToFileCalls() []struct {
	FilenameParam string
	WParam        []io.Writer
} {
	var calls []struct {
		FilenameParam string
		WParam        []io.Writer
	}
	mock.lockMultiWriteToFile.RLock()
	calls = mock.calls.MultiWriteToFile
	mock.lockMultiWriteToFile.RUnlock()
	return calls
}

// ResetMultiWriteToFileCalls reset all the calls that were made to MultiWriteToFile.
func (mock *RequesterVariadicMock) ResetMultiWriteToFileCalls() {
	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = nil
	mock.lockMultiWriteToFile.Unlock()
}

// OneInterface calls OneInterfaceFunc.
func (mock *RequesterVariadicMock) OneInterface(aParam ...interface{}) bool {
	if mock.OneInterfaceFunc == nil {
		panic("RequesterVariadicMock.OneInterfaceFunc: method is nil but RequesterVariadic.OneInterface was just called")
	}
	callInfo := struct {
		AParam []interface{}
	}{
		AParam: aParam,
	}
	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = append(mock.calls.OneInterface, callInfo)
	mock.lockOneInterface.Unlock()
	return mock.OneInterfaceFunc(aParam...)
}

// OneInterfaceCalls gets all the calls that were made to OneInterface.
// Check the length with:
//
//	len(mockedRequesterVariadic.OneInterfaceCalls())
func (mock *RequesterVariadicMock) OneInterfaceCalls() []struct {
	AParam []interface{}
} {
	var calls []struct {
		AParam []interface{}
	}
	mock.lockOneInterface.RLock()
	calls = mock.calls.OneInterface
	mock.lockOneInterface.RUnlock()
	return calls
}

// ResetOneInterfaceCalls reset all the calls that were made to OneInterface.
func (mock *RequesterVariadicMock) ResetOneInterfaceCalls() {
	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = nil
	mock.lockOneInterface.Unlock()
}

// Sprintf calls SprintfFunc.
func (mock *RequesterVariadicMock) Sprintf(formatParam string, aParam ...interface{}) string {
	if mock.SprintfFunc == nil {
		panic("RequesterVariadicMock.SprintfFunc: method is nil but RequesterVariadic.Sprintf was just called")
	}
	callInfo := struct {
		FormatParam string
		AParam      []interface{}
	}{
		FormatParam: formatParam,
		AParam:      aParam,
	}
	mock.lockSprintf.Lock()
	mock.calls.Sprintf = append(mock.calls.Sprintf, callInfo)
	mock.lockSprintf.Unlock()
	return mock.SprintfFunc(formatParam, aParam...)
}

// SprintfCalls gets all the calls that were made to Sprintf.
// Check the length with:
//
//	len(mockedRequesterVariadic.SprintfCalls())
func (mock *RequesterVariadicMock) SprintfCalls() []struct {
	FormatParam string
	AParam      []interface{}
} {
	var calls []struct {
		FormatParam string
		AParam      []interface{}
	}
	mock.lockSprintf.RLock()
	calls = mock.calls.Sprintf
	mock.lockSprintf.RUnlock()
	return calls
}

// ResetSprintfCalls reset all the calls that were made to Sprintf.
func (mock *RequesterVariadicMock) ResetSprintfCalls() {
	mock.lockSprintf.Lock()
	mock.calls.Sprintf = nil
	mock.lockSprintf.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterVariadicMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = nil
	mock.lockMultiWriteToFile.Unlock()

	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = nil
	mock.lockOneInterface.Unlock()

	mock.lockSprintf.Lock()
	mock.calls.Sprintf = nil
	mock.lockSprintf.Unlock()
}

// ExampleMock is a mock implementation of test.Example.
//
//	func TestSomethingThatUsesExample(t *testing.T) {
//
//		// make and configure a mocked test.Example
//		mockedExample := &ExampleMock{
//			AFunc: func() http.Flusher {
//				panic("mock out the A method")
//			},
//			BFunc: func(fixtureshttpParam string) my_http.MyStruct {
//				panic("mock out the B method")
//			},
//			CFunc: func(fixtureshttpParam string) number_dir_http.MyStruct {
//				panic("mock out the C method")
//			},
//		}
//
//		// use mockedExample in code that requires test.Example
//		// and then make assertions.
//
//	}
type ExampleMock struct {
	// AFunc mocks the A method.
	AFunc func() http.Flusher

	// BFunc mocks the B method.
	BFunc func(fixtureshttpParam string) my_http.MyStruct

	// CFunc mocks the C method.
	CFunc func(fixtureshttpParam string) number_dir_http.MyStruct

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
		}
		// B holds details about calls to the B method.
		B []struct {
			// FixtureshttpParam is the fixtureshttpParam argument value.
			FixtureshttpParam string
		}
		// C holds details about calls to the C method.
		C []struct {
			// FixtureshttpParam is the fixtureshttpParam argument value.
			FixtureshttpParam string
		}
	}
	lockA sync.RWMutex
	lockB sync.RWMutex
	lockC sync.RWMutex
}

// A calls AFunc.
func (mock *ExampleMock) A() http.Flusher {
	if mock.AFunc == nil {
		panic("ExampleMock.AFunc: method is nil but Example.A was just called")
	}
	callInfo := struct {
	}{}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	return mock.AFunc()
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedExample.ACalls())
func (mock *ExampleMock) ACalls() []struct {
} {
	var calls []struct {
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *ExampleMock) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// B calls BFunc.
func (mock *ExampleMock) B(fixtureshttpParam string) my_http.MyStruct {
	if mock.BFunc == nil {
		panic("ExampleMock.BFunc: method is nil but Example.B was just called")
	}
	callInfo := struct {
		FixtureshttpParam string
	}{
		FixtureshttpParam: fixtureshttpParam,
	}
	mock.lockB.Lock()
	mock.calls.B = append(mock.calls.B, callInfo)
	mock.lockB.Unlock()
	return mock.BFunc(fixtureshttpParam)
}

// BCalls gets all the calls that were made to B.
// Check the length with:
//
//	len(mockedExample.BCalls())
func (mock *ExampleMock) BCalls() []struct {
	FixtureshttpParam string
} {
	var calls []struct {
		FixtureshttpParam string
	}
	mock.lockB.RLock()
	calls = mock.calls.B
	mock.lockB.RUnlock()
	return calls
}

// ResetBCalls reset all the calls that were made to B.
func (mock *ExampleMock) ResetBCalls() {
	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()
}

// C calls CFunc.
func (mock *ExampleMock) C(fixtureshttpParam string) number_dir_http.MyStruct {
	if mock.CFunc == nil {
		panic("ExampleMock.CFunc: method is nil but Example.C was just called")
	}
	callInfo := struct {
		FixtureshttpParam string
	}{
		FixtureshttpParam: fixtureshttpParam,
	}
	mock.lockC.Lock()
	mock.calls.C = append(mock.calls.C, callInfo)
	mock.lockC.Unlock()
	return mock.CFunc(fixtureshttpParam)
}

// CCalls gets all the calls that were made to C.
// Check the length with:
//
//	len(mockedExample.CCalls())
func (mock *ExampleMock) CCalls() []struct {
	FixtureshttpParam string
} {
	var calls []struct {
		FixtureshttpParam string
	}
	mock.lockC.RLock()
	calls = mock.calls.C
	mock.lockC.RUnlock()
	return calls
}

// ResetCCalls reset all the calls that were made to C.
func (mock *ExampleMock) ResetCCalls() {
	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ExampleMock) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()

	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()

	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// AMock is a mock implementation of test.A.
//
//	func TestSomethingThatUsesA(t *testing.T) {
//
//		// make and configure a mocked test.A
//		mockedA := &AMock{
//			CallFunc: func() (fixtures.B, error) {
//				panic("mock out the Call method")
//			},
//		}
//
//		// use mockedA in code that requires test.A
//		// and then make assertions.
//
//	}
type AMock struct {
	// CallFunc mocks the Call method.
	CallFunc func() (fixtures.B, error)

	// calls tracks calls to the methods.
	calls struct {
		// Call holds details about calls to the Call method.
		Call []struct {
		}
	}
	lockCall sync.RWMutex
}

// Call calls CallFunc.
func (mock *AMock) Call() (fixtures.B, error) {
	if mock.CallFunc == nil {
		panic("AMock.CallFunc: method is nil but A.Call was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCall.Lock()
	mock.calls.Call = append(mock.calls.Call, callInfo)
	mock.lockCall.Unlock()
	return mock.CallFunc()
}

// CallCalls gets all the calls that were made to Call.
// Check the length with:
//
//	len(mockedA.CallCalls())
func (mock *AMock) CallCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCall.RLock()
	calls = mock.calls.Call
	mock.lockCall.RUnlock()
	return calls
}

// ResetCallCalls reset all the calls that were made to Call.
func (mock *AMock) ResetCallCalls() {
	mock.lockCall.Lock()
	mock.calls.Call = nil
	mock.lockCall.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *AMock) ResetCalls() {
	mock.lockCall.Lock()
	mock.calls.Call = nil
	mock.lockCall.Unlock()
}

// StructWithTagMock is a mock implementation of test.StructWithTag.
//
//	func TestSomethingThatUsesStructWithTag(t *testing.T) {
//
//		// make and configure a mocked test.StructWithTag
//		mockedStructWithTag := &StructWithTagMock{
//			MethodAFunc: func(vParam *struct{FieldA int "json:\"field_a\""; FieldB int "json:\"field_b\" xml:\"field_b\""}) *struct{FieldC int "json:\"field_c\""; FieldD int "json:\"field_d\" xml:\"field_d\""} {
//				panic("mock out the MethodA method")
//			},
//		}
//
//		// use mockedStructWithTag in code that requires test.StructWithTag
//		// and then make assertions.
//
//	}
type StructWithTagMock struct {
	// MethodAFunc mocks the MethodA method.
	MethodAFunc func(vParam *struct {
		FieldA int "json:\"field_a\""
		FieldB int "json:\"field_b\" xml:\"field_b\""
	}) *struct {
		FieldC int "json:\"field_c\""
		FieldD int "json:\"field_d\" xml:\"field_d\""
	}

	// calls tracks calls to the methods.
	calls struct {
		// MethodA holds details about calls to the MethodA method.
		MethodA []struct {
			// VParam is the vParam argument value.
			VParam *struct {
				FieldA int "json:\"field_a\""
				FieldB int "json:\"field_b\" xml:\"field_b\""
			}
		}
	}
	lockMethodA sync.RWMutex
}

// MethodA calls MethodAFunc.
func (mock *StructWithTagMock) MethodA(vParam *struct {
	FieldA int "json:\"field_a\""
	FieldB int "json:\"field_b\" xml:\"field_b\""
}) *struct {
	FieldC int "json:\"field_c\""
	FieldD int "json:\"field_d\" xml:\"field_d\""
} {
	if mock.MethodAFunc == nil {
		panic("StructWithTagMock.MethodAFunc: method is nil but StructWithTag.MethodA was just called")
	}
	callInfo := struct {
		VParam *struct {
			FieldA int "json:\"field_a\""
			FieldB int "json:\"field_b\" xml:\"field_b\""
		}
	}{
		VParam: vParam,
	}
	mock.lockMethodA.Lock()
	mock.calls.MethodA = append(mock.calls.MethodA, callInfo)
	mock.lockMethodA.Unlock()
	return mock.MethodAFunc(vParam)
}

// MethodACalls gets all the calls that were made to MethodA.
// Check the length with:
//
//	len(mockedStructWithTag.MethodACalls())
func (mock *StructWithTagMock) MethodACalls() []struct {
	VParam *struct {
		FieldA int "json:\"field_a\""
		FieldB int "json:\"field_b\" xml:\"field_b\""
	}
} {
	var calls []struct {
		VParam *struct {
			FieldA int "json:\"field_a\""
			FieldB int "json:\"field_b\" xml:\"field_b\""
		}
	}
	mock.lockMethodA.RLock()
	calls = mock.calls.MethodA
	mock.lockMethodA.RUnlock()
	return calls
}

// ResetMethodACalls reset all the calls that were made to MethodA.
func (mock *StructWithTagMock) ResetMethodACalls() {
	mock.lockMethodA.Lock()
	mock.calls.MethodA = nil
	mock.lockMethodA.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *StructWithTagMock) ResetCalls() {
	mock.lockMethodA.Lock()
	mock.calls.MethodA = nil
	mock.lockMethodA.Unlock()
}

// VariadicMock is a mock implementation of test.Variadic.
//
//	func TestSomethingThatUsesVariadic(t *testing.T) {
//
//		// make and configure a mocked test.Variadic
//		mockedVariadic := &VariadicMock{
//			VariadicFunctionFunc: func(strParam string, vFuncParam fixtures.VariadicFunction) error {
//				panic("mock out the VariadicFunction method")
//			},
//		}
//
//		// use mockedVariadic in code that requires test.Variadic
//		// and then make assertions.
//
//	}
type VariadicMock struct {
	// VariadicFunctionFunc mocks the VariadicFunction method.
	VariadicFunctionFunc func(strParam string, vFuncParam fixtures.VariadicFunction) error

	// calls tracks calls to the methods.
	calls struct {
		// VariadicFunction holds details about calls to the VariadicFunction method.
		VariadicFunction []struct {
			// StrParam is the strParam argument value.
			StrParam string
			// VFuncParam is the vFuncParam argument value.
			VFuncParam fixtures.VariadicFunction
		}
	}
	lockVariadicFunction sync.RWMutex
}

// VariadicFunction calls VariadicFunctionFunc.
func (mock *VariadicMock) VariadicFunction(strParam string, vFuncParam fixtures.VariadicFunction) error {
	if mock.VariadicFunctionFunc == nil {
		panic("VariadicMock.VariadicFunctionFunc: method is nil but Variadic.VariadicFunction was just called")
	}
	callInfo := struct {
		StrParam   string
		VFuncParam fixtures.VariadicFunction
	}{
		StrParam:   strParam,
		VFuncParam: vFuncParam,
	}
	mock.lockVariadicFunction.Lock()
	mock.calls.VariadicFunction = append(mock.calls.VariadicFunction, callInfo)
	mock.lockVariadicFunction.Unlock()
	return mock.VariadicFunctionFunc(strParam, vFuncParam)
}

// VariadicFunctionCalls gets all the calls that were made to VariadicFunction.
// Check the length with:
//
//	len(mockedVariadic.VariadicFunctionCalls())
func (mock *VariadicMock) VariadicFunctionCalls() []struct {
	StrParam   string
	VFuncParam fixtures.VariadicFunction
} {
	var calls []struct {
		StrParam   string
		VFuncParam fixtures.VariadicFunction
	}
	mock.lockVariadicFunction.RLock()
	calls = mock.calls.VariadicFunction
	mock.lockVariadicFunction.RUnlock()
	return calls
}

// ResetVariadicFunctionCalls reset all the calls that were made to VariadicFunction.
func (mock *VariadicMock) ResetVariadicFunctionCalls() {
	mock.lockVariadicFunction.Lock()
	mock.calls.VariadicFunction = nil
	mock.lockVariadicFunction.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *VariadicMock) ResetCalls() {
	mock.lockVariadicFunction.Lock()
	mock.calls.VariadicFunction = nil
	mock.lockVariadicFunction.Unlock()
}

// VariadicReturnFuncMock is a mock implementation of test.VariadicReturnFunc.
//
//	func TestSomethingThatUsesVariadicReturnFunc(t *testing.T) {
//
//		// make and configure a mocked test.VariadicReturnFunc
//		mockedVariadicReturnFunc := &VariadicReturnFuncMock{
//			SampleMethodFunc: func(strParam string) func(str string, arr []int, a ...interface{}) {
//				panic("mock out the SampleMethod method")
//			},
//		}
//
//		// use mockedVariadicReturnFunc in code that requires test.VariadicReturnFunc
//		// and then make assertions.
//
//	}
type VariadicReturnFuncMock struct {
	// SampleMethodFunc mocks the SampleMethod method.
	SampleMethodFunc func(strParam string) func(str string, arr []int, a ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// SampleMethod holds details about calls to the SampleMethod method.
		SampleMethod []struct {
			// StrParam is the strParam argument value.
			StrParam string
		}
	}
	lockSampleMethod sync.RWMutex
}

// SampleMethod calls SampleMethodFunc.
func (mock *VariadicReturnFuncMock) SampleMethod(strParam string) func(str string, arr []int, a ...interface{}) {
	if mock.SampleMethodFunc == nil {
		panic("VariadicReturnFuncMock.SampleMethodFunc: method is nil but VariadicReturnFunc.SampleMethod was just called")
	}
	callInfo := struct {
		StrParam string
	}{
		StrParam: strParam,
	}
	mock.lockSampleMethod.Lock()
	mock.calls.SampleMethod = append(mock.calls.SampleMethod, callInfo)
	mock.lockSampleMethod.Unlock()
	return mock.SampleMethodFunc(strParam)
}

// SampleMethodCalls gets all the calls that were made to SampleMethod.
// Check the length with:
//
//	len(mockedVariadicReturnFunc.SampleMethodCalls())
func (mock *VariadicReturnFuncMock) SampleMethodCalls() []struct {
	StrParam string
} {
	var calls []struct {
		StrParam string
	}
	mock.lockSampleMethod.RLock()
	calls = mock.calls.SampleMethod
	mock.lockSampleMethod.RUnlock()
	return calls
}

// ResetSampleMethodCalls reset all the calls that were made to SampleMethod.
func (mock *VariadicReturnFuncMock) ResetSampleMethodCalls() {
	mock.lockSampleMethod.Lock()
	mock.calls.SampleMethod = nil
	mock.lockSampleMethod.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *VariadicReturnFuncMock) ResetCalls() {
	mock.lockSampleMethod.Lock()
	mock.calls.SampleMethod = nil
	mock.lockSampleMethod.Unlock()
}
