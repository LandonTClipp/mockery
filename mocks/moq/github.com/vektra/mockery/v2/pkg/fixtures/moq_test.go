// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery

package test

import (
	"encoding/json"
	"io"
	"net/http"
	"sync"

	test "github.com/vektra/mockery/v2/pkg/fixtures"
	http1 "github.com/vektra/mockery/v2/pkg/fixtures/12345678/http"
	"github.com/vektra/mockery/v2/pkg/fixtures/constraints"
	http0 "github.com/vektra/mockery/v2/pkg/fixtures/http"
	test0 "github.com/vektra/mockery/v2/pkg/fixtures/redefined_type_b"
)

// UsesAnyMock is a mock implementation of test.UsesAny.
//
//	func TestSomethingThatUsesUsesAny(t *testing.T) {
//
//		// make and configure a mocked test.UsesAny
//		mockedUsesAny := &UsesAnyMock{
//			GetReaderFunc: func() any {
//				panic("mock out the GetReader method")
//			},
//		}
//
//		// use mockedUsesAny in code that requires test.UsesAny
//		// and then make assertions.
//
//	}
type UsesAnyMock struct {
	// GetReaderFunc mocks the GetReader method.
	GetReaderFunc func() any

	// calls tracks calls to the methods.
	calls struct {
		// GetReader holds details about calls to the GetReader method.
		GetReader []struct {
		}
	}
	lockGetReader sync.RWMutex
}

// GetReader calls GetReaderFunc.
func (mock *UsesAnyMock) GetReader() any {
	if mock.GetReaderFunc == nil {
		panic("UsesAnyMock.GetReaderFunc: method is nil but UsesAny.GetReader was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetReader.Lock()
	mock.calls.GetReader = append(mock.calls.GetReader, callInfo)
	mock.lockGetReader.Unlock()
	return mock.GetReaderFunc()
}

// GetReaderCalls gets all the calls that were made to GetReader.
// Check the length with:
//
//	len(mockedUsesAny.GetReaderCalls())
func (mock *UsesAnyMock) GetReaderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetReader.RLock()
	calls = mock.calls.GetReader
	mock.lockGetReader.RUnlock()
	return calls
}

// ResetGetReaderCalls reset all the calls that were made to GetReader.
func (mock *UsesAnyMock) ResetGetReaderCalls() {
	mock.lockGetReader.Lock()
	mock.calls.GetReader = nil
	mock.lockGetReader.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *UsesAnyMock) ResetCalls() {
	mock.lockGetReader.Lock()
	mock.calls.GetReader = nil
	mock.lockGetReader.Unlock()
}

// FooerMock is a mock implementation of test.Fooer.
//
//	func TestSomethingThatUsesFooer(t *testing.T) {
//
//		// make and configure a mocked test.Fooer
//		mockedFooer := &FooerMock{
//			BarFunc: func(f func([]int))  {
//				panic("mock out the Bar method")
//			},
//			BazFunc: func(path string) func(x string) string {
//				panic("mock out the Baz method")
//			},
//			FooFunc: func(f func(x string) string) error {
//				panic("mock out the Foo method")
//			},
//		}
//
//		// use mockedFooer in code that requires test.Fooer
//		// and then make assertions.
//
//	}
type FooerMock struct {
	// BarFunc mocks the Bar method.
	BarFunc func(f func([]int))

	// BazFunc mocks the Baz method.
	BazFunc func(path string) func(x string) string

	// FooFunc mocks the Foo method.
	FooFunc func(f func(x string) string) error

	// calls tracks calls to the methods.
	calls struct {
		// Bar holds details about calls to the Bar method.
		Bar []struct {
			// F is the f argument value.
			F func([]int)
		}
		// Baz holds details about calls to the Baz method.
		Baz []struct {
			// Path is the path argument value.
			Path string
		}
		// Foo holds details about calls to the Foo method.
		Foo []struct {
			// F is the f argument value.
			F func(x string) string
		}
	}
	lockBar sync.RWMutex
	lockBaz sync.RWMutex
	lockFoo sync.RWMutex
}

// Bar calls BarFunc.
func (mock *FooerMock) Bar(f func([]int)) {
	if mock.BarFunc == nil {
		panic("FooerMock.BarFunc: method is nil but Fooer.Bar was just called")
	}
	callInfo := struct {
		F func([]int)
	}{
		F: f,
	}
	mock.lockBar.Lock()
	mock.calls.Bar = append(mock.calls.Bar, callInfo)
	mock.lockBar.Unlock()
	mock.BarFunc(f)
}

// BarCalls gets all the calls that were made to Bar.
// Check the length with:
//
//	len(mockedFooer.BarCalls())
func (mock *FooerMock) BarCalls() []struct {
	F func([]int)
} {
	var calls []struct {
		F func([]int)
	}
	mock.lockBar.RLock()
	calls = mock.calls.Bar
	mock.lockBar.RUnlock()
	return calls
}

// ResetBarCalls reset all the calls that were made to Bar.
func (mock *FooerMock) ResetBarCalls() {
	mock.lockBar.Lock()
	mock.calls.Bar = nil
	mock.lockBar.Unlock()
}

// Baz calls BazFunc.
func (mock *FooerMock) Baz(path string) func(x string) string {
	if mock.BazFunc == nil {
		panic("FooerMock.BazFunc: method is nil but Fooer.Baz was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockBaz.Lock()
	mock.calls.Baz = append(mock.calls.Baz, callInfo)
	mock.lockBaz.Unlock()
	return mock.BazFunc(path)
}

// BazCalls gets all the calls that were made to Baz.
// Check the length with:
//
//	len(mockedFooer.BazCalls())
func (mock *FooerMock) BazCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockBaz.RLock()
	calls = mock.calls.Baz
	mock.lockBaz.RUnlock()
	return calls
}

// ResetBazCalls reset all the calls that were made to Baz.
func (mock *FooerMock) ResetBazCalls() {
	mock.lockBaz.Lock()
	mock.calls.Baz = nil
	mock.lockBaz.Unlock()
}

// Foo calls FooFunc.
func (mock *FooerMock) Foo(f func(x string) string) error {
	if mock.FooFunc == nil {
		panic("FooerMock.FooFunc: method is nil but Fooer.Foo was just called")
	}
	callInfo := struct {
		F func(x string) string
	}{
		F: f,
	}
	mock.lockFoo.Lock()
	mock.calls.Foo = append(mock.calls.Foo, callInfo)
	mock.lockFoo.Unlock()
	return mock.FooFunc(f)
}

// FooCalls gets all the calls that were made to Foo.
// Check the length with:
//
//	len(mockedFooer.FooCalls())
func (mock *FooerMock) FooCalls() []struct {
	F func(x string) string
} {
	var calls []struct {
		F func(x string) string
	}
	mock.lockFoo.RLock()
	calls = mock.calls.Foo
	mock.lockFoo.RUnlock()
	return calls
}

// ResetFooCalls reset all the calls that were made to Foo.
func (mock *FooerMock) ResetFooCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *FooerMock) ResetCalls() {
	mock.lockBar.Lock()
	mock.calls.Bar = nil
	mock.lockBar.Unlock()

	mock.lockBaz.Lock()
	mock.calls.Baz = nil
	mock.lockBaz.Unlock()

	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// MapFuncMock is a mock implementation of test.MapFunc.
//
//	func TestSomethingThatUsesMapFunc(t *testing.T) {
//
//		// make and configure a mocked test.MapFunc
//		mockedMapFunc := &MapFuncMock{
//			GetFunc: func(m map[string]func(string) string) error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedMapFunc in code that requires test.MapFunc
//		// and then make assertions.
//
//	}
type MapFuncMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(m map[string]func(string) string) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// M is the m argument value.
			M map[string]func(string) string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MapFuncMock) Get(m map[string]func(string) string) error {
	if mock.GetFunc == nil {
		panic("MapFuncMock.GetFunc: method is nil but MapFunc.Get was just called")
	}
	callInfo := struct {
		M map[string]func(string) string
	}{
		M: m,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(m)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedMapFunc.GetCalls())
func (mock *MapFuncMock) GetCalls() []struct {
	M map[string]func(string) string
} {
	var calls []struct {
		M map[string]func(string) string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MapFuncMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MapFuncMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// AsyncProducerMock is a mock implementation of test.AsyncProducer.
//
//	func TestSomethingThatUsesAsyncProducer(t *testing.T) {
//
//		// make and configure a mocked test.AsyncProducer
//		mockedAsyncProducer := &AsyncProducerMock{
//			InputFunc: func() chan<- bool {
//				panic("mock out the Input method")
//			},
//			OutputFunc: func() <-chan bool {
//				panic("mock out the Output method")
//			},
//			WhateverFunc: func() chan bool {
//				panic("mock out the Whatever method")
//			},
//		}
//
//		// use mockedAsyncProducer in code that requires test.AsyncProducer
//		// and then make assertions.
//
//	}
type AsyncProducerMock struct {
	// InputFunc mocks the Input method.
	InputFunc func() chan<- bool

	// OutputFunc mocks the Output method.
	OutputFunc func() <-chan bool

	// WhateverFunc mocks the Whatever method.
	WhateverFunc func() chan bool

	// calls tracks calls to the methods.
	calls struct {
		// Input holds details about calls to the Input method.
		Input []struct {
		}
		// Output holds details about calls to the Output method.
		Output []struct {
		}
		// Whatever holds details about calls to the Whatever method.
		Whatever []struct {
		}
	}
	lockInput    sync.RWMutex
	lockOutput   sync.RWMutex
	lockWhatever sync.RWMutex
}

// Input calls InputFunc.
func (mock *AsyncProducerMock) Input() chan<- bool {
	if mock.InputFunc == nil {
		panic("AsyncProducerMock.InputFunc: method is nil but AsyncProducer.Input was just called")
	}
	callInfo := struct {
	}{}
	mock.lockInput.Lock()
	mock.calls.Input = append(mock.calls.Input, callInfo)
	mock.lockInput.Unlock()
	return mock.InputFunc()
}

// InputCalls gets all the calls that were made to Input.
// Check the length with:
//
//	len(mockedAsyncProducer.InputCalls())
func (mock *AsyncProducerMock) InputCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInput.RLock()
	calls = mock.calls.Input
	mock.lockInput.RUnlock()
	return calls
}

// ResetInputCalls reset all the calls that were made to Input.
func (mock *AsyncProducerMock) ResetInputCalls() {
	mock.lockInput.Lock()
	mock.calls.Input = nil
	mock.lockInput.Unlock()
}

// Output calls OutputFunc.
func (mock *AsyncProducerMock) Output() <-chan bool {
	if mock.OutputFunc == nil {
		panic("AsyncProducerMock.OutputFunc: method is nil but AsyncProducer.Output was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOutput.Lock()
	mock.calls.Output = append(mock.calls.Output, callInfo)
	mock.lockOutput.Unlock()
	return mock.OutputFunc()
}

// OutputCalls gets all the calls that were made to Output.
// Check the length with:
//
//	len(mockedAsyncProducer.OutputCalls())
func (mock *AsyncProducerMock) OutputCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOutput.RLock()
	calls = mock.calls.Output
	mock.lockOutput.RUnlock()
	return calls
}

// ResetOutputCalls reset all the calls that were made to Output.
func (mock *AsyncProducerMock) ResetOutputCalls() {
	mock.lockOutput.Lock()
	mock.calls.Output = nil
	mock.lockOutput.Unlock()
}

// Whatever calls WhateverFunc.
func (mock *AsyncProducerMock) Whatever() chan bool {
	if mock.WhateverFunc == nil {
		panic("AsyncProducerMock.WhateverFunc: method is nil but AsyncProducer.Whatever was just called")
	}
	callInfo := struct {
	}{}
	mock.lockWhatever.Lock()
	mock.calls.Whatever = append(mock.calls.Whatever, callInfo)
	mock.lockWhatever.Unlock()
	return mock.WhateverFunc()
}

// WhateverCalls gets all the calls that were made to Whatever.
// Check the length with:
//
//	len(mockedAsyncProducer.WhateverCalls())
func (mock *AsyncProducerMock) WhateverCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWhatever.RLock()
	calls = mock.calls.Whatever
	mock.lockWhatever.RUnlock()
	return calls
}

// ResetWhateverCalls reset all the calls that were made to Whatever.
func (mock *AsyncProducerMock) ResetWhateverCalls() {
	mock.lockWhatever.Lock()
	mock.calls.Whatever = nil
	mock.lockWhatever.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *AsyncProducerMock) ResetCalls() {
	mock.lockInput.Lock()
	mock.calls.Input = nil
	mock.lockInput.Unlock()

	mock.lockOutput.Lock()
	mock.calls.Output = nil
	mock.lockOutput.Unlock()

	mock.lockWhatever.Lock()
	mock.calls.Whatever = nil
	mock.lockWhatever.Unlock()
}

// ConsulLockMock is a mock implementation of test.ConsulLock.
//
//	func TestSomethingThatUsesConsulLock(t *testing.T) {
//
//		// make and configure a mocked test.ConsulLock
//		mockedConsulLock := &ConsulLockMock{
//			LockFunc: func(valCh <-chan struct{}) (<-chan struct{}, error) {
//				panic("mock out the Lock method")
//			},
//			UnlockFunc: func() error {
//				panic("mock out the Unlock method")
//			},
//		}
//
//		// use mockedConsulLock in code that requires test.ConsulLock
//		// and then make assertions.
//
//	}
type ConsulLockMock struct {
	// LockFunc mocks the Lock method.
	LockFunc func(valCh <-chan struct{}) (<-chan struct{}, error)

	// UnlockFunc mocks the Unlock method.
	UnlockFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Lock holds details about calls to the Lock method.
		Lock []struct {
			// ValCh is the valCh argument value.
			ValCh <-chan struct{}
		}
		// Unlock holds details about calls to the Unlock method.
		Unlock []struct {
		}
	}
	lockLock   sync.RWMutex
	lockUnlock sync.RWMutex
}

// Lock calls LockFunc.
func (mock *ConsulLockMock) Lock(valCh <-chan struct{}) (<-chan struct{}, error) {
	if mock.LockFunc == nil {
		panic("ConsulLockMock.LockFunc: method is nil but ConsulLock.Lock was just called")
	}
	callInfo := struct {
		ValCh <-chan struct{}
	}{
		ValCh: valCh,
	}
	mock.lockLock.Lock()
	mock.calls.Lock = append(mock.calls.Lock, callInfo)
	mock.lockLock.Unlock()
	return mock.LockFunc(valCh)
}

// LockCalls gets all the calls that were made to Lock.
// Check the length with:
//
//	len(mockedConsulLock.LockCalls())
func (mock *ConsulLockMock) LockCalls() []struct {
	ValCh <-chan struct{}
} {
	var calls []struct {
		ValCh <-chan struct{}
	}
	mock.lockLock.RLock()
	calls = mock.calls.Lock
	mock.lockLock.RUnlock()
	return calls
}

// ResetLockCalls reset all the calls that were made to Lock.
func (mock *ConsulLockMock) ResetLockCalls() {
	mock.lockLock.Lock()
	mock.calls.Lock = nil
	mock.lockLock.Unlock()
}

// Unlock calls UnlockFunc.
func (mock *ConsulLockMock) Unlock() error {
	if mock.UnlockFunc == nil {
		panic("ConsulLockMock.UnlockFunc: method is nil but ConsulLock.Unlock was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUnlock.Lock()
	mock.calls.Unlock = append(mock.calls.Unlock, callInfo)
	mock.lockUnlock.Unlock()
	return mock.UnlockFunc()
}

// UnlockCalls gets all the calls that were made to Unlock.
// Check the length with:
//
//	len(mockedConsulLock.UnlockCalls())
func (mock *ConsulLockMock) UnlockCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUnlock.RLock()
	calls = mock.calls.Unlock
	mock.lockUnlock.RUnlock()
	return calls
}

// ResetUnlockCalls reset all the calls that were made to Unlock.
func (mock *ConsulLockMock) ResetUnlockCalls() {
	mock.lockUnlock.Lock()
	mock.calls.Unlock = nil
	mock.lockUnlock.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ConsulLockMock) ResetCalls() {
	mock.lockLock.Lock()
	mock.calls.Lock = nil
	mock.lockLock.Unlock()

	mock.lockUnlock.Lock()
	mock.calls.Unlock = nil
	mock.lockUnlock.Unlock()
}

// KeyManagerMock is a mock implementation of test.KeyManager.
//
//	func TestSomethingThatUsesKeyManager(t *testing.T) {
//
//		// make and configure a mocked test.KeyManager
//		mockedKeyManager := &KeyManagerMock{
//			GetKeyFunc: func(s string, v uint16) ([]byte, *test.Err) {
//				panic("mock out the GetKey method")
//			},
//		}
//
//		// use mockedKeyManager in code that requires test.KeyManager
//		// and then make assertions.
//
//	}
type KeyManagerMock struct {
	// GetKeyFunc mocks the GetKey method.
	GetKeyFunc func(s string, v uint16) ([]byte, *test.Err)

	// calls tracks calls to the methods.
	calls struct {
		// GetKey holds details about calls to the GetKey method.
		GetKey []struct {
			// S is the s argument value.
			S string
			// V is the v argument value.
			V uint16
		}
	}
	lockGetKey sync.RWMutex
}

// GetKey calls GetKeyFunc.
func (mock *KeyManagerMock) GetKey(s string, v uint16) ([]byte, *test.Err) {
	if mock.GetKeyFunc == nil {
		panic("KeyManagerMock.GetKeyFunc: method is nil but KeyManager.GetKey was just called")
	}
	callInfo := struct {
		S string
		V uint16
	}{
		S: s,
		V: v,
	}
	mock.lockGetKey.Lock()
	mock.calls.GetKey = append(mock.calls.GetKey, callInfo)
	mock.lockGetKey.Unlock()
	return mock.GetKeyFunc(s, v)
}

// GetKeyCalls gets all the calls that were made to GetKey.
// Check the length with:
//
//	len(mockedKeyManager.GetKeyCalls())
func (mock *KeyManagerMock) GetKeyCalls() []struct {
	S string
	V uint16
} {
	var calls []struct {
		S string
		V uint16
	}
	mock.lockGetKey.RLock()
	calls = mock.calls.GetKey
	mock.lockGetKey.RUnlock()
	return calls
}

// ResetGetKeyCalls reset all the calls that were made to GetKey.
func (mock *KeyManagerMock) ResetGetKeyCalls() {
	mock.lockGetKey.Lock()
	mock.calls.GetKey = nil
	mock.lockGetKey.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *KeyManagerMock) ResetCalls() {
	mock.lockGetKey.Lock()
	mock.calls.GetKey = nil
	mock.lockGetKey.Unlock()
}

// BlankMock is a mock implementation of test.Blank.
//
//	func TestSomethingThatUsesBlank(t *testing.T) {
//
//		// make and configure a mocked test.Blank
//		mockedBlank := &BlankMock{
//			CreateFunc: func(x interface{}) error {
//				panic("mock out the Create method")
//			},
//		}
//
//		// use mockedBlank in code that requires test.Blank
//		// and then make assertions.
//
//	}
type BlankMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(x interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// X is the x argument value.
			X interface{}
		}
	}
	lockCreate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *BlankMock) Create(x interface{}) error {
	if mock.CreateFunc == nil {
		panic("BlankMock.CreateFunc: method is nil but Blank.Create was just called")
	}
	callInfo := struct {
		X interface{}
	}{
		X: x,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(x)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedBlank.CreateCalls())
func (mock *BlankMock) CreateCalls() []struct {
	X interface{}
} {
	var calls []struct {
		X interface{}
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// ResetCreateCalls reset all the calls that were made to Create.
func (mock *BlankMock) ResetCreateCalls() {
	mock.lockCreate.Lock()
	mock.calls.Create = nil
	mock.lockCreate.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *BlankMock) ResetCalls() {
	mock.lockCreate.Lock()
	mock.calls.Create = nil
	mock.lockCreate.Unlock()
}

// ExpecterMock is a mock implementation of test.Expecter.
//
//	func TestSomethingThatUsesExpecter(t *testing.T) {
//
//		// make and configure a mocked test.Expecter
//		mockedExpecter := &ExpecterMock{
//			ManyArgsReturnsFunc: func(str string, i int) ([]string, error) {
//				panic("mock out the ManyArgsReturns method")
//			},
//			NoArgFunc: func() string {
//				panic("mock out the NoArg method")
//			},
//			NoReturnFunc: func(str string)  {
//				panic("mock out the NoReturn method")
//			},
//			VariadicFunc: func(ints ...int) error {
//				panic("mock out the Variadic method")
//			},
//			VariadicManyFunc: func(i int, a string, intfs ...interface{}) error {
//				panic("mock out the VariadicMany method")
//			},
//		}
//
//		// use mockedExpecter in code that requires test.Expecter
//		// and then make assertions.
//
//	}
type ExpecterMock struct {
	// ManyArgsReturnsFunc mocks the ManyArgsReturns method.
	ManyArgsReturnsFunc func(str string, i int) ([]string, error)

	// NoArgFunc mocks the NoArg method.
	NoArgFunc func() string

	// NoReturnFunc mocks the NoReturn method.
	NoReturnFunc func(str string)

	// VariadicFunc mocks the Variadic method.
	VariadicFunc func(ints ...int) error

	// VariadicManyFunc mocks the VariadicMany method.
	VariadicManyFunc func(i int, a string, intfs ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// ManyArgsReturns holds details about calls to the ManyArgsReturns method.
		ManyArgsReturns []struct {
			// Str is the str argument value.
			Str string
			// I is the i argument value.
			I int
		}
		// NoArg holds details about calls to the NoArg method.
		NoArg []struct {
		}
		// NoReturn holds details about calls to the NoReturn method.
		NoReturn []struct {
			// Str is the str argument value.
			Str string
		}
		// Variadic holds details about calls to the Variadic method.
		Variadic []struct {
			// Ints is the ints argument value.
			Ints []int
		}
		// VariadicMany holds details about calls to the VariadicMany method.
		VariadicMany []struct {
			// I is the i argument value.
			I int
			// A is the a argument value.
			A string
			// Intfs is the intfs argument value.
			Intfs []interface{}
		}
	}
	lockManyArgsReturns sync.RWMutex
	lockNoArg           sync.RWMutex
	lockNoReturn        sync.RWMutex
	lockVariadic        sync.RWMutex
	lockVariadicMany    sync.RWMutex
}

// ManyArgsReturns calls ManyArgsReturnsFunc.
func (mock *ExpecterMock) ManyArgsReturns(str string, i int) ([]string, error) {
	if mock.ManyArgsReturnsFunc == nil {
		panic("ExpecterMock.ManyArgsReturnsFunc: method is nil but Expecter.ManyArgsReturns was just called")
	}
	callInfo := struct {
		Str string
		I   int
	}{
		Str: str,
		I:   i,
	}
	mock.lockManyArgsReturns.Lock()
	mock.calls.ManyArgsReturns = append(mock.calls.ManyArgsReturns, callInfo)
	mock.lockManyArgsReturns.Unlock()
	return mock.ManyArgsReturnsFunc(str, i)
}

// ManyArgsReturnsCalls gets all the calls that were made to ManyArgsReturns.
// Check the length with:
//
//	len(mockedExpecter.ManyArgsReturnsCalls())
func (mock *ExpecterMock) ManyArgsReturnsCalls() []struct {
	Str string
	I   int
} {
	var calls []struct {
		Str string
		I   int
	}
	mock.lockManyArgsReturns.RLock()
	calls = mock.calls.ManyArgsReturns
	mock.lockManyArgsReturns.RUnlock()
	return calls
}

// ResetManyArgsReturnsCalls reset all the calls that were made to ManyArgsReturns.
func (mock *ExpecterMock) ResetManyArgsReturnsCalls() {
	mock.lockManyArgsReturns.Lock()
	mock.calls.ManyArgsReturns = nil
	mock.lockManyArgsReturns.Unlock()
}

// NoArg calls NoArgFunc.
func (mock *ExpecterMock) NoArg() string {
	if mock.NoArgFunc == nil {
		panic("ExpecterMock.NoArgFunc: method is nil but Expecter.NoArg was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNoArg.Lock()
	mock.calls.NoArg = append(mock.calls.NoArg, callInfo)
	mock.lockNoArg.Unlock()
	return mock.NoArgFunc()
}

// NoArgCalls gets all the calls that were made to NoArg.
// Check the length with:
//
//	len(mockedExpecter.NoArgCalls())
func (mock *ExpecterMock) NoArgCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNoArg.RLock()
	calls = mock.calls.NoArg
	mock.lockNoArg.RUnlock()
	return calls
}

// ResetNoArgCalls reset all the calls that were made to NoArg.
func (mock *ExpecterMock) ResetNoArgCalls() {
	mock.lockNoArg.Lock()
	mock.calls.NoArg = nil
	mock.lockNoArg.Unlock()
}

// NoReturn calls NoReturnFunc.
func (mock *ExpecterMock) NoReturn(str string) {
	if mock.NoReturnFunc == nil {
		panic("ExpecterMock.NoReturnFunc: method is nil but Expecter.NoReturn was just called")
	}
	callInfo := struct {
		Str string
	}{
		Str: str,
	}
	mock.lockNoReturn.Lock()
	mock.calls.NoReturn = append(mock.calls.NoReturn, callInfo)
	mock.lockNoReturn.Unlock()
	mock.NoReturnFunc(str)
}

// NoReturnCalls gets all the calls that were made to NoReturn.
// Check the length with:
//
//	len(mockedExpecter.NoReturnCalls())
func (mock *ExpecterMock) NoReturnCalls() []struct {
	Str string
} {
	var calls []struct {
		Str string
	}
	mock.lockNoReturn.RLock()
	calls = mock.calls.NoReturn
	mock.lockNoReturn.RUnlock()
	return calls
}

// ResetNoReturnCalls reset all the calls that were made to NoReturn.
func (mock *ExpecterMock) ResetNoReturnCalls() {
	mock.lockNoReturn.Lock()
	mock.calls.NoReturn = nil
	mock.lockNoReturn.Unlock()
}

// Variadic calls VariadicFunc.
func (mock *ExpecterMock) Variadic(ints ...int) error {
	if mock.VariadicFunc == nil {
		panic("ExpecterMock.VariadicFunc: method is nil but Expecter.Variadic was just called")
	}
	callInfo := struct {
		Ints []int
	}{
		Ints: ints,
	}
	mock.lockVariadic.Lock()
	mock.calls.Variadic = append(mock.calls.Variadic, callInfo)
	mock.lockVariadic.Unlock()
	return mock.VariadicFunc(ints...)
}

// VariadicCalls gets all the calls that were made to Variadic.
// Check the length with:
//
//	len(mockedExpecter.VariadicCalls())
func (mock *ExpecterMock) VariadicCalls() []struct {
	Ints []int
} {
	var calls []struct {
		Ints []int
	}
	mock.lockVariadic.RLock()
	calls = mock.calls.Variadic
	mock.lockVariadic.RUnlock()
	return calls
}

// ResetVariadicCalls reset all the calls that were made to Variadic.
func (mock *ExpecterMock) ResetVariadicCalls() {
	mock.lockVariadic.Lock()
	mock.calls.Variadic = nil
	mock.lockVariadic.Unlock()
}

// VariadicMany calls VariadicManyFunc.
func (mock *ExpecterMock) VariadicMany(i int, a string, intfs ...interface{}) error {
	if mock.VariadicManyFunc == nil {
		panic("ExpecterMock.VariadicManyFunc: method is nil but Expecter.VariadicMany was just called")
	}
	callInfo := struct {
		I     int
		A     string
		Intfs []interface{}
	}{
		I:     i,
		A:     a,
		Intfs: intfs,
	}
	mock.lockVariadicMany.Lock()
	mock.calls.VariadicMany = append(mock.calls.VariadicMany, callInfo)
	mock.lockVariadicMany.Unlock()
	return mock.VariadicManyFunc(i, a, intfs...)
}

// VariadicManyCalls gets all the calls that were made to VariadicMany.
// Check the length with:
//
//	len(mockedExpecter.VariadicManyCalls())
func (mock *ExpecterMock) VariadicManyCalls() []struct {
	I     int
	A     string
	Intfs []interface{}
} {
	var calls []struct {
		I     int
		A     string
		Intfs []interface{}
	}
	mock.lockVariadicMany.RLock()
	calls = mock.calls.VariadicMany
	mock.lockVariadicMany.RUnlock()
	return calls
}

// ResetVariadicManyCalls reset all the calls that were made to VariadicMany.
func (mock *ExpecterMock) ResetVariadicManyCalls() {
	mock.lockVariadicMany.Lock()
	mock.calls.VariadicMany = nil
	mock.lockVariadicMany.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ExpecterMock) ResetCalls() {
	mock.lockManyArgsReturns.Lock()
	mock.calls.ManyArgsReturns = nil
	mock.lockManyArgsReturns.Unlock()

	mock.lockNoArg.Lock()
	mock.calls.NoArg = nil
	mock.lockNoArg.Unlock()

	mock.lockNoReturn.Lock()
	mock.calls.NoReturn = nil
	mock.lockNoReturn.Unlock()

	mock.lockVariadic.Lock()
	mock.calls.Variadic = nil
	mock.lockVariadic.Unlock()

	mock.lockVariadicMany.Lock()
	mock.calls.VariadicMany = nil
	mock.lockVariadicMany.Unlock()
}

// VariadicNoReturnInterfaceMock is a mock implementation of test.VariadicNoReturnInterface.
//
//	func TestSomethingThatUsesVariadicNoReturnInterface(t *testing.T) {
//
//		// make and configure a mocked test.VariadicNoReturnInterface
//		mockedVariadicNoReturnInterface := &VariadicNoReturnInterfaceMock{
//			VariadicNoReturnFunc: func(j int, is ...interface{})  {
//				panic("mock out the VariadicNoReturn method")
//			},
//		}
//
//		// use mockedVariadicNoReturnInterface in code that requires test.VariadicNoReturnInterface
//		// and then make assertions.
//
//	}
type VariadicNoReturnInterfaceMock struct {
	// VariadicNoReturnFunc mocks the VariadicNoReturn method.
	VariadicNoReturnFunc func(j int, is ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// VariadicNoReturn holds details about calls to the VariadicNoReturn method.
		VariadicNoReturn []struct {
			// J is the j argument value.
			J int
			// Is is the is argument value.
			Is []interface{}
		}
	}
	lockVariadicNoReturn sync.RWMutex
}

// VariadicNoReturn calls VariadicNoReturnFunc.
func (mock *VariadicNoReturnInterfaceMock) VariadicNoReturn(j int, is ...interface{}) {
	if mock.VariadicNoReturnFunc == nil {
		panic("VariadicNoReturnInterfaceMock.VariadicNoReturnFunc: method is nil but VariadicNoReturnInterface.VariadicNoReturn was just called")
	}
	callInfo := struct {
		J  int
		Is []interface{}
	}{
		J:  j,
		Is: is,
	}
	mock.lockVariadicNoReturn.Lock()
	mock.calls.VariadicNoReturn = append(mock.calls.VariadicNoReturn, callInfo)
	mock.lockVariadicNoReturn.Unlock()
	mock.VariadicNoReturnFunc(j, is...)
}

// VariadicNoReturnCalls gets all the calls that were made to VariadicNoReturn.
// Check the length with:
//
//	len(mockedVariadicNoReturnInterface.VariadicNoReturnCalls())
func (mock *VariadicNoReturnInterfaceMock) VariadicNoReturnCalls() []struct {
	J  int
	Is []interface{}
} {
	var calls []struct {
		J  int
		Is []interface{}
	}
	mock.lockVariadicNoReturn.RLock()
	calls = mock.calls.VariadicNoReturn
	mock.lockVariadicNoReturn.RUnlock()
	return calls
}

// ResetVariadicNoReturnCalls reset all the calls that were made to VariadicNoReturn.
func (mock *VariadicNoReturnInterfaceMock) ResetVariadicNoReturnCalls() {
	mock.lockVariadicNoReturn.Lock()
	mock.calls.VariadicNoReturn = nil
	mock.lockVariadicNoReturn.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *VariadicNoReturnInterfaceMock) ResetCalls() {
	mock.lockVariadicNoReturn.Lock()
	mock.calls.VariadicNoReturn = nil
	mock.lockVariadicNoReturn.Unlock()
}

// FuncArgsCollisionMock is a mock implementation of test.FuncArgsCollision.
//
//	func TestSomethingThatUsesFuncArgsCollision(t *testing.T) {
//
//		// make and configure a mocked test.FuncArgsCollision
//		mockedFuncArgsCollision := &FuncArgsCollisionMock{
//			FooFunc: func(ret interface{}) error {
//				panic("mock out the Foo method")
//			},
//		}
//
//		// use mockedFuncArgsCollision in code that requires test.FuncArgsCollision
//		// and then make assertions.
//
//	}
type FuncArgsCollisionMock struct {
	// FooFunc mocks the Foo method.
	FooFunc func(ret interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Foo holds details about calls to the Foo method.
		Foo []struct {
			// Ret is the ret argument value.
			Ret interface{}
		}
	}
	lockFoo sync.RWMutex
}

// Foo calls FooFunc.
func (mock *FuncArgsCollisionMock) Foo(ret interface{}) error {
	if mock.FooFunc == nil {
		panic("FuncArgsCollisionMock.FooFunc: method is nil but FuncArgsCollision.Foo was just called")
	}
	callInfo := struct {
		Ret interface{}
	}{
		Ret: ret,
	}
	mock.lockFoo.Lock()
	mock.calls.Foo = append(mock.calls.Foo, callInfo)
	mock.lockFoo.Unlock()
	return mock.FooFunc(ret)
}

// FooCalls gets all the calls that were made to Foo.
// Check the length with:
//
//	len(mockedFuncArgsCollision.FooCalls())
func (mock *FuncArgsCollisionMock) FooCalls() []struct {
	Ret interface{}
} {
	var calls []struct {
		Ret interface{}
	}
	mock.lockFoo.RLock()
	calls = mock.calls.Foo
	mock.lockFoo.RUnlock()
	return calls
}

// ResetFooCalls reset all the calls that were made to Foo.
func (mock *FuncArgsCollisionMock) ResetFooCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *FuncArgsCollisionMock) ResetCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// GetIntMock is a mock implementation of test.GetInt.
//
//	func TestSomethingThatUsesGetInt(t *testing.T) {
//
//		// make and configure a mocked test.GetInt
//		mockedGetInt := &GetIntMock{
//			GetFunc: func() int {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedGetInt in code that requires test.GetInt
//		// and then make assertions.
//
//	}
type GetIntMock struct {
	// GetFunc mocks the Get method.
	GetFunc func() int

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *GetIntMock) Get() int {
	if mock.GetFunc == nil {
		panic("GetIntMock.GetFunc: method is nil but GetInt.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedGetInt.GetCalls())
func (mock *GetIntMock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *GetIntMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *GetIntMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// GetGenericMock is a mock implementation of test.GetGeneric.
//
//	func TestSomethingThatUsesGetGeneric(t *testing.T) {
//
//		// make and configure a mocked test.GetGeneric
//		mockedGetGeneric := &GetGenericMock{
//			GetFunc: func() T {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedGetGeneric in code that requires test.GetGeneric
//		// and then make assertions.
//
//	}
type GetGenericMock[T constraints.Integer] struct {
	// GetFunc mocks the Get method.
	GetFunc func() T

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *GetGenericMock[T]) Get() T {
	if mock.GetFunc == nil {
		panic("GetGenericMock.GetFunc: method is nil but GetGeneric.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedGetGeneric.GetCalls())
func (mock *GetGenericMock[T]) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *GetGenericMock[T]) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *GetGenericMock[T]) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// EmbeddedGetMock is a mock implementation of test.EmbeddedGet.
//
//	func TestSomethingThatUsesEmbeddedGet(t *testing.T) {
//
//		// make and configure a mocked test.EmbeddedGet
//		mockedEmbeddedGet := &EmbeddedGetMock{
//			GetFunc: func() T {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedEmbeddedGet in code that requires test.EmbeddedGet
//		// and then make assertions.
//
//	}
type EmbeddedGetMock[T constraints.Signed] struct {
	// GetFunc mocks the Get method.
	GetFunc func() T

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *EmbeddedGetMock[T]) Get() T {
	if mock.GetFunc == nil {
		panic("EmbeddedGetMock.GetFunc: method is nil but EmbeddedGet.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedEmbeddedGet.GetCalls())
func (mock *EmbeddedGetMock[T]) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *EmbeddedGetMock[T]) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *EmbeddedGetMock[T]) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ReplaceGenericMock is a mock implementation of test.ReplaceGeneric.
//
//	func TestSomethingThatUsesReplaceGeneric(t *testing.T) {
//
//		// make and configure a mocked test.ReplaceGeneric
//		mockedReplaceGeneric := &ReplaceGenericMock{
//			AFunc: func(t1 TImport) TKeep {
//				panic("mock out the A method")
//			},
//			BFunc: func() TImport {
//				panic("mock out the B method")
//			},
//			CFunc: func() TConstraint {
//				panic("mock out the C method")
//			},
//		}
//
//		// use mockedReplaceGeneric in code that requires test.ReplaceGeneric
//		// and then make assertions.
//
//	}
type ReplaceGenericMock[TImport any, TConstraint constraints.Signed, TKeep any] struct {
	// AFunc mocks the A method.
	AFunc func(t1 TImport) TKeep

	// BFunc mocks the B method.
	BFunc func() TImport

	// CFunc mocks the C method.
	CFunc func() TConstraint

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
			// T1 is the t1 argument value.
			T1 TImport
		}
		// B holds details about calls to the B method.
		B []struct {
		}
		// C holds details about calls to the C method.
		C []struct {
		}
	}
	lockA sync.RWMutex
	lockB sync.RWMutex
	lockC sync.RWMutex
}

// A calls AFunc.
func (mock *ReplaceGenericMock[TImport, TConstraint, TKeep]) A(t1 TImport) TKeep {
	if mock.AFunc == nil {
		panic("ReplaceGenericMock.AFunc: method is nil but ReplaceGeneric.A was just called")
	}
	callInfo := struct {
		T1 TImport
	}{
		T1: t1,
	}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	return mock.AFunc(t1)
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedReplaceGeneric.ACalls())
func (mock *ReplaceGenericMock[TImport, TConstraint, TKeep]) ACalls() []struct {
	T1 TImport
} {
	var calls []struct {
		T1 TImport
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *ReplaceGenericMock[TImport, TConstraint, TKeep]) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// B calls BFunc.
func (mock *ReplaceGenericMock[TImport, TConstraint, TKeep]) B() TImport {
	if mock.BFunc == nil {
		panic("ReplaceGenericMock.BFunc: method is nil but ReplaceGeneric.B was just called")
	}
	callInfo := struct {
	}{}
	mock.lockB.Lock()
	mock.calls.B = append(mock.calls.B, callInfo)
	mock.lockB.Unlock()
	return mock.BFunc()
}

// BCalls gets all the calls that were made to B.
// Check the length with:
//
//	len(mockedReplaceGeneric.BCalls())
func (mock *ReplaceGenericMock[TImport, TConstraint, TKeep]) BCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockB.RLock()
	calls = mock.calls.B
	mock.lockB.RUnlock()
	return calls
}

// ResetBCalls reset all the calls that were made to B.
func (mock *ReplaceGenericMock[TImport, TConstraint, TKeep]) ResetBCalls() {
	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()
}

// C calls CFunc.
func (mock *ReplaceGenericMock[TImport, TConstraint, TKeep]) C() TConstraint {
	if mock.CFunc == nil {
		panic("ReplaceGenericMock.CFunc: method is nil but ReplaceGeneric.C was just called")
	}
	callInfo := struct {
	}{}
	mock.lockC.Lock()
	mock.calls.C = append(mock.calls.C, callInfo)
	mock.lockC.Unlock()
	return mock.CFunc()
}

// CCalls gets all the calls that were made to C.
// Check the length with:
//
//	len(mockedReplaceGeneric.CCalls())
func (mock *ReplaceGenericMock[TImport, TConstraint, TKeep]) CCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockC.RLock()
	calls = mock.calls.C
	mock.lockC.RUnlock()
	return calls
}

// ResetCCalls reset all the calls that were made to C.
func (mock *ReplaceGenericMock[TImport, TConstraint, TKeep]) ResetCCalls() {
	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ReplaceGenericMock[TImport, TConstraint, TKeep]) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()

	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()

	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ReplaceGenericSelfMock is a mock implementation of test.ReplaceGenericSelf.
//
//	func TestSomethingThatUsesReplaceGenericSelf(t *testing.T) {
//
//		// make and configure a mocked test.ReplaceGenericSelf
//		mockedReplaceGenericSelf := &ReplaceGenericSelfMock{
//			AFunc: func() T {
//				panic("mock out the A method")
//			},
//		}
//
//		// use mockedReplaceGenericSelf in code that requires test.ReplaceGenericSelf
//		// and then make assertions.
//
//	}
type ReplaceGenericSelfMock[T any] struct {
	// AFunc mocks the A method.
	AFunc func() T

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
		}
	}
	lockA sync.RWMutex
}

// A calls AFunc.
func (mock *ReplaceGenericSelfMock[T]) A() T {
	if mock.AFunc == nil {
		panic("ReplaceGenericSelfMock.AFunc: method is nil but ReplaceGenericSelf.A was just called")
	}
	callInfo := struct {
	}{}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	return mock.AFunc()
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedReplaceGenericSelf.ACalls())
func (mock *ReplaceGenericSelfMock[T]) ACalls() []struct {
} {
	var calls []struct {
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *ReplaceGenericSelfMock[T]) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ReplaceGenericSelfMock[T]) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// HasConflictingNestedImportsMock is a mock implementation of test.HasConflictingNestedImports.
//
//	func TestSomethingThatUsesHasConflictingNestedImports(t *testing.T) {
//
//		// make and configure a mocked test.HasConflictingNestedImports
//		mockedHasConflictingNestedImports := &HasConflictingNestedImportsMock{
//			GetFunc: func(path string) (http.Response, error) {
//				panic("mock out the Get method")
//			},
//			ZFunc: func() http0.MyStruct {
//				panic("mock out the Z method")
//			},
//		}
//
//		// use mockedHasConflictingNestedImports in code that requires test.HasConflictingNestedImports
//		// and then make assertions.
//
//	}
type HasConflictingNestedImportsMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (http.Response, error)

	// ZFunc mocks the Z method.
	ZFunc func() http0.MyStruct

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
		// Z holds details about calls to the Z method.
		Z []struct {
		}
	}
	lockGet sync.RWMutex
	lockZ   sync.RWMutex
}

// Get calls GetFunc.
func (mock *HasConflictingNestedImportsMock) Get(path string) (http.Response, error) {
	if mock.GetFunc == nil {
		panic("HasConflictingNestedImportsMock.GetFunc: method is nil but HasConflictingNestedImports.Get was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedHasConflictingNestedImports.GetCalls())
func (mock *HasConflictingNestedImportsMock) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *HasConflictingNestedImportsMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Z calls ZFunc.
func (mock *HasConflictingNestedImportsMock) Z() http0.MyStruct {
	if mock.ZFunc == nil {
		panic("HasConflictingNestedImportsMock.ZFunc: method is nil but HasConflictingNestedImports.Z was just called")
	}
	callInfo := struct {
	}{}
	mock.lockZ.Lock()
	mock.calls.Z = append(mock.calls.Z, callInfo)
	mock.lockZ.Unlock()
	return mock.ZFunc()
}

// ZCalls gets all the calls that were made to Z.
// Check the length with:
//
//	len(mockedHasConflictingNestedImports.ZCalls())
func (mock *HasConflictingNestedImportsMock) ZCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockZ.RLock()
	calls = mock.calls.Z
	mock.lockZ.RUnlock()
	return calls
}

// ResetZCalls reset all the calls that were made to Z.
func (mock *HasConflictingNestedImportsMock) ResetZCalls() {
	mock.lockZ.Lock()
	mock.calls.Z = nil
	mock.lockZ.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *HasConflictingNestedImportsMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockZ.Lock()
	mock.calls.Z = nil
	mock.lockZ.Unlock()
}

// ImportsSameAsPackageMock is a mock implementation of test.ImportsSameAsPackage.
//
//	func TestSomethingThatUsesImportsSameAsPackage(t *testing.T) {
//
//		// make and configure a mocked test.ImportsSameAsPackage
//		mockedImportsSameAsPackage := &ImportsSameAsPackageMock{
//			AFunc: func() test0.B {
//				panic("mock out the A method")
//			},
//			BFunc: func() test.KeyManager {
//				panic("mock out the B method")
//			},
//			CFunc: func(c test.C)  {
//				panic("mock out the C method")
//			},
//		}
//
//		// use mockedImportsSameAsPackage in code that requires test.ImportsSameAsPackage
//		// and then make assertions.
//
//	}
type ImportsSameAsPackageMock struct {
	// AFunc mocks the A method.
	AFunc func() test0.B

	// BFunc mocks the B method.
	BFunc func() test.KeyManager

	// CFunc mocks the C method.
	CFunc func(c test.C)

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
		}
		// B holds details about calls to the B method.
		B []struct {
		}
		// C holds details about calls to the C method.
		C []struct {
			// C is the c argument value.
			C test.C
		}
	}
	lockA sync.RWMutex
	lockB sync.RWMutex
	lockC sync.RWMutex
}

// A calls AFunc.
func (mock *ImportsSameAsPackageMock) A() test0.B {
	if mock.AFunc == nil {
		panic("ImportsSameAsPackageMock.AFunc: method is nil but ImportsSameAsPackage.A was just called")
	}
	callInfo := struct {
	}{}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	return mock.AFunc()
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedImportsSameAsPackage.ACalls())
func (mock *ImportsSameAsPackageMock) ACalls() []struct {
} {
	var calls []struct {
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *ImportsSameAsPackageMock) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// B calls BFunc.
func (mock *ImportsSameAsPackageMock) B() test.KeyManager {
	if mock.BFunc == nil {
		panic("ImportsSameAsPackageMock.BFunc: method is nil but ImportsSameAsPackage.B was just called")
	}
	callInfo := struct {
	}{}
	mock.lockB.Lock()
	mock.calls.B = append(mock.calls.B, callInfo)
	mock.lockB.Unlock()
	return mock.BFunc()
}

// BCalls gets all the calls that were made to B.
// Check the length with:
//
//	len(mockedImportsSameAsPackage.BCalls())
func (mock *ImportsSameAsPackageMock) BCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockB.RLock()
	calls = mock.calls.B
	mock.lockB.RUnlock()
	return calls
}

// ResetBCalls reset all the calls that were made to B.
func (mock *ImportsSameAsPackageMock) ResetBCalls() {
	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()
}

// C calls CFunc.
func (mock *ImportsSameAsPackageMock) C(c test.C) {
	if mock.CFunc == nil {
		panic("ImportsSameAsPackageMock.CFunc: method is nil but ImportsSameAsPackage.C was just called")
	}
	callInfo := struct {
		C test.C
	}{
		C: c,
	}
	mock.lockC.Lock()
	mock.calls.C = append(mock.calls.C, callInfo)
	mock.lockC.Unlock()
	mock.CFunc(c)
}

// CCalls gets all the calls that were made to C.
// Check the length with:
//
//	len(mockedImportsSameAsPackage.CCalls())
func (mock *ImportsSameAsPackageMock) CCalls() []struct {
	C test.C
} {
	var calls []struct {
		C test.C
	}
	mock.lockC.RLock()
	calls = mock.calls.C
	mock.lockC.RUnlock()
	return calls
}

// ResetCCalls reset all the calls that were made to C.
func (mock *ImportsSameAsPackageMock) ResetCCalls() {
	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ImportsSameAsPackageMock) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()

	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()

	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// GenericInterfaceMock is a mock implementation of test.GenericInterface.
//
//	func TestSomethingThatUsesGenericInterface(t *testing.T) {
//
//		// make and configure a mocked test.GenericInterface
//		mockedGenericInterface := &GenericInterfaceMock{
//			FuncFunc: func(arg *M) int {
//				panic("mock out the Func method")
//			},
//		}
//
//		// use mockedGenericInterface in code that requires test.GenericInterface
//		// and then make assertions.
//
//	}
type GenericInterfaceMock[M any] struct {
	// FuncFunc mocks the Func method.
	FuncFunc func(arg *M) int

	// calls tracks calls to the methods.
	calls struct {
		// Func holds details about calls to the Func method.
		Func []struct {
			// Arg is the arg argument value.
			Arg *M
		}
	}
	lockFunc sync.RWMutex
}

// Func calls FuncFunc.
func (mock *GenericInterfaceMock[M]) Func(arg *M) int {
	if mock.FuncFunc == nil {
		panic("GenericInterfaceMock.FuncFunc: method is nil but GenericInterface.Func was just called")
	}
	callInfo := struct {
		Arg *M
	}{
		Arg: arg,
	}
	mock.lockFunc.Lock()
	mock.calls.Func = append(mock.calls.Func, callInfo)
	mock.lockFunc.Unlock()
	return mock.FuncFunc(arg)
}

// FuncCalls gets all the calls that were made to Func.
// Check the length with:
//
//	len(mockedGenericInterface.FuncCalls())
func (mock *GenericInterfaceMock[M]) FuncCalls() []struct {
	Arg *M
} {
	var calls []struct {
		Arg *M
	}
	mock.lockFunc.RLock()
	calls = mock.calls.Func
	mock.lockFunc.RUnlock()
	return calls
}

// ResetFuncCalls reset all the calls that were made to Func.
func (mock *GenericInterfaceMock[M]) ResetFuncCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *GenericInterfaceMock[M]) ResetCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// InstantiatedGenericInterfaceMock is a mock implementation of test.InstantiatedGenericInterface.
//
//	func TestSomethingThatUsesInstantiatedGenericInterface(t *testing.T) {
//
//		// make and configure a mocked test.InstantiatedGenericInterface
//		mockedInstantiatedGenericInterface := &InstantiatedGenericInterfaceMock{
//			FuncFunc: func(arg *float32) int {
//				panic("mock out the Func method")
//			},
//		}
//
//		// use mockedInstantiatedGenericInterface in code that requires test.InstantiatedGenericInterface
//		// and then make assertions.
//
//	}
type InstantiatedGenericInterfaceMock struct {
	// FuncFunc mocks the Func method.
	FuncFunc func(arg *float32) int

	// calls tracks calls to the methods.
	calls struct {
		// Func holds details about calls to the Func method.
		Func []struct {
			// Arg is the arg argument value.
			Arg *float32
		}
	}
	lockFunc sync.RWMutex
}

// Func calls FuncFunc.
func (mock *InstantiatedGenericInterfaceMock) Func(arg *float32) int {
	if mock.FuncFunc == nil {
		panic("InstantiatedGenericInterfaceMock.FuncFunc: method is nil but InstantiatedGenericInterface.Func was just called")
	}
	callInfo := struct {
		Arg *float32
	}{
		Arg: arg,
	}
	mock.lockFunc.Lock()
	mock.calls.Func = append(mock.calls.Func, callInfo)
	mock.lockFunc.Unlock()
	return mock.FuncFunc(arg)
}

// FuncCalls gets all the calls that were made to Func.
// Check the length with:
//
//	len(mockedInstantiatedGenericInterface.FuncCalls())
func (mock *InstantiatedGenericInterfaceMock) FuncCalls() []struct {
	Arg *float32
} {
	var calls []struct {
		Arg *float32
	}
	mock.lockFunc.RLock()
	calls = mock.calls.Func
	mock.lockFunc.RUnlock()
	return calls
}

// ResetFuncCalls reset all the calls that were made to Func.
func (mock *InstantiatedGenericInterfaceMock) ResetFuncCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *InstantiatedGenericInterfaceMock) ResetCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// MyReaderMock is a mock implementation of test.MyReader.
//
//	func TestSomethingThatUsesMyReader(t *testing.T) {
//
//		// make and configure a mocked test.MyReader
//		mockedMyReader := &MyReaderMock{
//			ReadFunc: func(p []byte) (int, error) {
//				panic("mock out the Read method")
//			},
//		}
//
//		// use mockedMyReader in code that requires test.MyReader
//		// and then make assertions.
//
//	}
type MyReaderMock struct {
	// ReadFunc mocks the Read method.
	ReadFunc func(p []byte) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Read holds details about calls to the Read method.
		Read []struct {
			// P is the p argument value.
			P []byte
		}
	}
	lockRead sync.RWMutex
}

// Read calls ReadFunc.
func (mock *MyReaderMock) Read(p []byte) (int, error) {
	if mock.ReadFunc == nil {
		panic("MyReaderMock.ReadFunc: method is nil but MyReader.Read was just called")
	}
	callInfo := struct {
		P []byte
	}{
		P: p,
	}
	mock.lockRead.Lock()
	mock.calls.Read = append(mock.calls.Read, callInfo)
	mock.lockRead.Unlock()
	return mock.ReadFunc(p)
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//	len(mockedMyReader.ReadCalls())
func (mock *MyReaderMock) ReadCalls() []struct {
	P []byte
} {
	var calls []struct {
		P []byte
	}
	mock.lockRead.RLock()
	calls = mock.calls.Read
	mock.lockRead.RUnlock()
	return calls
}

// ResetReadCalls reset all the calls that were made to Read.
func (mock *MyReaderMock) ResetReadCalls() {
	mock.lockRead.Lock()
	mock.calls.Read = nil
	mock.lockRead.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MyReaderMock) ResetCalls() {
	mock.lockRead.Lock()
	mock.calls.Read = nil
	mock.lockRead.Unlock()
}

// Issue766Mock is a mock implementation of test.Issue766.
//
//	func TestSomethingThatUsesIssue766(t *testing.T) {
//
//		// make and configure a mocked test.Issue766
//		mockedIssue766 := &Issue766Mock{
//			FetchDataFunc: func(fetchFunc func(x ...int) ([]int, error)) ([]int, error) {
//				panic("mock out the FetchData method")
//			},
//		}
//
//		// use mockedIssue766 in code that requires test.Issue766
//		// and then make assertions.
//
//	}
type Issue766Mock struct {
	// FetchDataFunc mocks the FetchData method.
	FetchDataFunc func(fetchFunc func(x ...int) ([]int, error)) ([]int, error)

	// calls tracks calls to the methods.
	calls struct {
		// FetchData holds details about calls to the FetchData method.
		FetchData []struct {
			// FetchFunc is the fetchFunc argument value.
			FetchFunc func(x ...int) ([]int, error)
		}
	}
	lockFetchData sync.RWMutex
}

// FetchData calls FetchDataFunc.
func (mock *Issue766Mock) FetchData(fetchFunc func(x ...int) ([]int, error)) ([]int, error) {
	if mock.FetchDataFunc == nil {
		panic("Issue766Mock.FetchDataFunc: method is nil but Issue766.FetchData was just called")
	}
	callInfo := struct {
		FetchFunc func(x ...int) ([]int, error)
	}{
		FetchFunc: fetchFunc,
	}
	mock.lockFetchData.Lock()
	mock.calls.FetchData = append(mock.calls.FetchData, callInfo)
	mock.lockFetchData.Unlock()
	return mock.FetchDataFunc(fetchFunc)
}

// FetchDataCalls gets all the calls that were made to FetchData.
// Check the length with:
//
//	len(mockedIssue766.FetchDataCalls())
func (mock *Issue766Mock) FetchDataCalls() []struct {
	FetchFunc func(x ...int) ([]int, error)
} {
	var calls []struct {
		FetchFunc func(x ...int) ([]int, error)
	}
	mock.lockFetchData.RLock()
	calls = mock.calls.FetchData
	mock.lockFetchData.RUnlock()
	return calls
}

// ResetFetchDataCalls reset all the calls that were made to FetchData.
func (mock *Issue766Mock) ResetFetchDataCalls() {
	mock.lockFetchData.Lock()
	mock.calls.FetchData = nil
	mock.lockFetchData.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *Issue766Mock) ResetCalls() {
	mock.lockFetchData.Lock()
	mock.calls.FetchData = nil
	mock.lockFetchData.Unlock()
}

// MapToInterfaceMock is a mock implementation of test.MapToInterface.
//
//	func TestSomethingThatUsesMapToInterface(t *testing.T) {
//
//		// make and configure a mocked test.MapToInterface
//		mockedMapToInterface := &MapToInterfaceMock{
//			FooFunc: func(arg1 ...map[string]interface{})  {
//				panic("mock out the Foo method")
//			},
//		}
//
//		// use mockedMapToInterface in code that requires test.MapToInterface
//		// and then make assertions.
//
//	}
type MapToInterfaceMock struct {
	// FooFunc mocks the Foo method.
	FooFunc func(arg1 ...map[string]interface{})

	// calls tracks calls to the methods.
	calls struct {
		// Foo holds details about calls to the Foo method.
		Foo []struct {
			// Arg1 is the arg1 argument value.
			Arg1 []map[string]interface{}
		}
	}
	lockFoo sync.RWMutex
}

// Foo calls FooFunc.
func (mock *MapToInterfaceMock) Foo(arg1 ...map[string]interface{}) {
	if mock.FooFunc == nil {
		panic("MapToInterfaceMock.FooFunc: method is nil but MapToInterface.Foo was just called")
	}
	callInfo := struct {
		Arg1 []map[string]interface{}
	}{
		Arg1: arg1,
	}
	mock.lockFoo.Lock()
	mock.calls.Foo = append(mock.calls.Foo, callInfo)
	mock.lockFoo.Unlock()
	mock.FooFunc(arg1...)
}

// FooCalls gets all the calls that were made to Foo.
// Check the length with:
//
//	len(mockedMapToInterface.FooCalls())
func (mock *MapToInterfaceMock) FooCalls() []struct {
	Arg1 []map[string]interface{}
} {
	var calls []struct {
		Arg1 []map[string]interface{}
	}
	mock.lockFoo.RLock()
	calls = mock.calls.Foo
	mock.lockFoo.RUnlock()
	return calls
}

// ResetFooCalls reset all the calls that were made to Foo.
func (mock *MapToInterfaceMock) ResetFooCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MapToInterfaceMock) ResetCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// SiblingMock is a mock implementation of test.Sibling.
//
//	func TestSomethingThatUsesSibling(t *testing.T) {
//
//		// make and configure a mocked test.Sibling
//		mockedSibling := &SiblingMock{
//			DoSomethingFunc: func()  {
//				panic("mock out the DoSomething method")
//			},
//		}
//
//		// use mockedSibling in code that requires test.Sibling
//		// and then make assertions.
//
//	}
type SiblingMock struct {
	// DoSomethingFunc mocks the DoSomething method.
	DoSomethingFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// DoSomething holds details about calls to the DoSomething method.
		DoSomething []struct {
		}
	}
	lockDoSomething sync.RWMutex
}

// DoSomething calls DoSomethingFunc.
func (mock *SiblingMock) DoSomething() {
	if mock.DoSomethingFunc == nil {
		panic("SiblingMock.DoSomethingFunc: method is nil but Sibling.DoSomething was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = append(mock.calls.DoSomething, callInfo)
	mock.lockDoSomething.Unlock()
	mock.DoSomethingFunc()
}

// DoSomethingCalls gets all the calls that were made to DoSomething.
// Check the length with:
//
//	len(mockedSibling.DoSomethingCalls())
func (mock *SiblingMock) DoSomethingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDoSomething.RLock()
	calls = mock.calls.DoSomething
	mock.lockDoSomething.RUnlock()
	return calls
}

// ResetDoSomethingCalls reset all the calls that were made to DoSomething.
func (mock *SiblingMock) ResetDoSomethingCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *SiblingMock) ResetCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// UsesOtherPkgIfaceMock is a mock implementation of test.UsesOtherPkgIface.
//
//	func TestSomethingThatUsesUsesOtherPkgIface(t *testing.T) {
//
//		// make and configure a mocked test.UsesOtherPkgIface
//		mockedUsesOtherPkgIface := &UsesOtherPkgIfaceMock{
//			DoSomethingElseFunc: func(obj test.Sibling)  {
//				panic("mock out the DoSomethingElse method")
//			},
//		}
//
//		// use mockedUsesOtherPkgIface in code that requires test.UsesOtherPkgIface
//		// and then make assertions.
//
//	}
type UsesOtherPkgIfaceMock struct {
	// DoSomethingElseFunc mocks the DoSomethingElse method.
	DoSomethingElseFunc func(obj test.Sibling)

	// calls tracks calls to the methods.
	calls struct {
		// DoSomethingElse holds details about calls to the DoSomethingElse method.
		DoSomethingElse []struct {
			// Obj is the obj argument value.
			Obj test.Sibling
		}
	}
	lockDoSomethingElse sync.RWMutex
}

// DoSomethingElse calls DoSomethingElseFunc.
func (mock *UsesOtherPkgIfaceMock) DoSomethingElse(obj test.Sibling) {
	if mock.DoSomethingElseFunc == nil {
		panic("UsesOtherPkgIfaceMock.DoSomethingElseFunc: method is nil but UsesOtherPkgIface.DoSomethingElse was just called")
	}
	callInfo := struct {
		Obj test.Sibling
	}{
		Obj: obj,
	}
	mock.lockDoSomethingElse.Lock()
	mock.calls.DoSomethingElse = append(mock.calls.DoSomethingElse, callInfo)
	mock.lockDoSomethingElse.Unlock()
	mock.DoSomethingElseFunc(obj)
}

// DoSomethingElseCalls gets all the calls that were made to DoSomethingElse.
// Check the length with:
//
//	len(mockedUsesOtherPkgIface.DoSomethingElseCalls())
func (mock *UsesOtherPkgIfaceMock) DoSomethingElseCalls() []struct {
	Obj test.Sibling
} {
	var calls []struct {
		Obj test.Sibling
	}
	mock.lockDoSomethingElse.RLock()
	calls = mock.calls.DoSomethingElse
	mock.lockDoSomethingElse.RUnlock()
	return calls
}

// ResetDoSomethingElseCalls reset all the calls that were made to DoSomethingElse.
func (mock *UsesOtherPkgIfaceMock) ResetDoSomethingElseCalls() {
	mock.lockDoSomethingElse.Lock()
	mock.calls.DoSomethingElse = nil
	mock.lockDoSomethingElse.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *UsesOtherPkgIfaceMock) ResetCalls() {
	mock.lockDoSomethingElse.Lock()
	mock.calls.DoSomethingElse = nil
	mock.lockDoSomethingElse.Unlock()
}

// PanicOnNoReturnValueMock is a mock implementation of test.PanicOnNoReturnValue.
//
//	func TestSomethingThatUsesPanicOnNoReturnValue(t *testing.T) {
//
//		// make and configure a mocked test.PanicOnNoReturnValue
//		mockedPanicOnNoReturnValue := &PanicOnNoReturnValueMock{
//			DoSomethingFunc: func() string {
//				panic("mock out the DoSomething method")
//			},
//		}
//
//		// use mockedPanicOnNoReturnValue in code that requires test.PanicOnNoReturnValue
//		// and then make assertions.
//
//	}
type PanicOnNoReturnValueMock struct {
	// DoSomethingFunc mocks the DoSomething method.
	DoSomethingFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// DoSomething holds details about calls to the DoSomething method.
		DoSomething []struct {
		}
	}
	lockDoSomething sync.RWMutex
}

// DoSomething calls DoSomethingFunc.
func (mock *PanicOnNoReturnValueMock) DoSomething() string {
	if mock.DoSomethingFunc == nil {
		panic("PanicOnNoReturnValueMock.DoSomethingFunc: method is nil but PanicOnNoReturnValue.DoSomething was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = append(mock.calls.DoSomething, callInfo)
	mock.lockDoSomething.Unlock()
	return mock.DoSomethingFunc()
}

// DoSomethingCalls gets all the calls that were made to DoSomething.
// Check the length with:
//
//	len(mockedPanicOnNoReturnValue.DoSomethingCalls())
func (mock *PanicOnNoReturnValueMock) DoSomethingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDoSomething.RLock()
	calls = mock.calls.DoSomething
	mock.lockDoSomething.RUnlock()
	return calls
}

// ResetDoSomethingCalls reset all the calls that were made to DoSomething.
func (mock *PanicOnNoReturnValueMock) ResetDoSomethingCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *PanicOnNoReturnValueMock) ResetCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// RequesterMock is a mock implementation of test.Requester.
//
//	func TestSomethingThatUsesRequester(t *testing.T) {
//
//		// make and configure a mocked test.Requester
//		mockedRequester := &RequesterMock{
//			GetFunc: func(path string) (string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester in code that requires test.Requester
//		// and then make assertions.
//
//	}
type RequesterMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterMock) Get(path string) (string, error) {
	if mock.GetFunc == nil {
		panic("RequesterMock.GetFunc: method is nil but Requester.Get was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester.GetCalls())
func (mock *RequesterMock) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Requester2Mock is a mock implementation of test.Requester2.
//
//	func TestSomethingThatUsesRequester2(t *testing.T) {
//
//		// make and configure a mocked test.Requester2
//		mockedRequester2 := &Requester2Mock{
//			GetFunc: func(path string) error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester2 in code that requires test.Requester2
//		// and then make assertions.
//
//	}
type Requester2Mock struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *Requester2Mock) Get(path string) error {
	if mock.GetFunc == nil {
		panic("Requester2Mock.GetFunc: method is nil but Requester2.Get was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester2.GetCalls())
func (mock *Requester2Mock) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *Requester2Mock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *Requester2Mock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Requester3Mock is a mock implementation of test.Requester3.
//
//	func TestSomethingThatUsesRequester3(t *testing.T) {
//
//		// make and configure a mocked test.Requester3
//		mockedRequester3 := &Requester3Mock{
//			GetFunc: func() error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester3 in code that requires test.Requester3
//		// and then make assertions.
//
//	}
type Requester3Mock struct {
	// GetFunc mocks the Get method.
	GetFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *Requester3Mock) Get() error {
	if mock.GetFunc == nil {
		panic("Requester3Mock.GetFunc: method is nil but Requester3.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester3.GetCalls())
func (mock *Requester3Mock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *Requester3Mock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *Requester3Mock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Requester4Mock is a mock implementation of test.Requester4.
//
//	func TestSomethingThatUsesRequester4(t *testing.T) {
//
//		// make and configure a mocked test.Requester4
//		mockedRequester4 := &Requester4Mock{
//			GetFunc: func()  {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester4 in code that requires test.Requester4
//		// and then make assertions.
//
//	}
type Requester4Mock struct {
	// GetFunc mocks the Get method.
	GetFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *Requester4Mock) Get() {
	if mock.GetFunc == nil {
		panic("Requester4Mock.GetFunc: method is nil but Requester4.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester4.GetCalls())
func (mock *Requester4Mock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *Requester4Mock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *Requester4Mock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterArgSameAsImportMock is a mock implementation of test.RequesterArgSameAsImport.
//
//	func TestSomethingThatUsesRequesterArgSameAsImport(t *testing.T) {
//
//		// make and configure a mocked test.RequesterArgSameAsImport
//		mockedRequesterArgSameAsImport := &RequesterArgSameAsImportMock{
//			GetFunc: func(json1 string) *json.RawMessage {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArgSameAsImport in code that requires test.RequesterArgSameAsImport
//		// and then make assertions.
//
//	}
type RequesterArgSameAsImportMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(json1 string) *json.RawMessage

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Json1 is the json1 argument value.
			Json1 string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterArgSameAsImportMock) Get(json1 string) *json.RawMessage {
	if mock.GetFunc == nil {
		panic("RequesterArgSameAsImportMock.GetFunc: method is nil but RequesterArgSameAsImport.Get was just called")
	}
	callInfo := struct {
		Json1 string
	}{
		Json1: json1,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(json1)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArgSameAsImport.GetCalls())
func (mock *RequesterArgSameAsImportMock) GetCalls() []struct {
	Json1 string
} {
	var calls []struct {
		Json1 string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterArgSameAsImportMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterArgSameAsImportMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterArgSameAsNamedImportMock is a mock implementation of test.RequesterArgSameAsNamedImport.
//
//	func TestSomethingThatUsesRequesterArgSameAsNamedImport(t *testing.T) {
//
//		// make and configure a mocked test.RequesterArgSameAsNamedImport
//		mockedRequesterArgSameAsNamedImport := &RequesterArgSameAsNamedImportMock{
//			GetFunc: func(json1 string) *json.RawMessage {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArgSameAsNamedImport in code that requires test.RequesterArgSameAsNamedImport
//		// and then make assertions.
//
//	}
type RequesterArgSameAsNamedImportMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(json1 string) *json.RawMessage

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Json1 is the json1 argument value.
			Json1 string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterArgSameAsNamedImportMock) Get(json1 string) *json.RawMessage {
	if mock.GetFunc == nil {
		panic("RequesterArgSameAsNamedImportMock.GetFunc: method is nil but RequesterArgSameAsNamedImport.Get was just called")
	}
	callInfo := struct {
		Json1 string
	}{
		Json1: json1,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(json1)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArgSameAsNamedImport.GetCalls())
func (mock *RequesterArgSameAsNamedImportMock) GetCalls() []struct {
	Json1 string
} {
	var calls []struct {
		Json1 string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterArgSameAsNamedImportMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterArgSameAsNamedImportMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterArgSameAsPkgMock is a mock implementation of test.RequesterArgSameAsPkg.
//
//	func TestSomethingThatUsesRequesterArgSameAsPkg(t *testing.T) {
//
//		// make and configure a mocked test.RequesterArgSameAsPkg
//		mockedRequesterArgSameAsPkg := &RequesterArgSameAsPkgMock{
//			GetFunc: func(test1 string)  {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArgSameAsPkg in code that requires test.RequesterArgSameAsPkg
//		// and then make assertions.
//
//	}
type RequesterArgSameAsPkgMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(test1 string)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Test1 is the test1 argument value.
			Test1 string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterArgSameAsPkgMock) Get(test1 string) {
	if mock.GetFunc == nil {
		panic("RequesterArgSameAsPkgMock.GetFunc: method is nil but RequesterArgSameAsPkg.Get was just called")
	}
	callInfo := struct {
		Test1 string
	}{
		Test1: test1,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	mock.GetFunc(test1)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArgSameAsPkg.GetCalls())
func (mock *RequesterArgSameAsPkgMock) GetCalls() []struct {
	Test1 string
} {
	var calls []struct {
		Test1 string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterArgSameAsPkgMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterArgSameAsPkgMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterArrayMock is a mock implementation of test.RequesterArray.
//
//	func TestSomethingThatUsesRequesterArray(t *testing.T) {
//
//		// make and configure a mocked test.RequesterArray
//		mockedRequesterArray := &RequesterArrayMock{
//			GetFunc: func(path string) ([2]string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArray in code that requires test.RequesterArray
//		// and then make assertions.
//
//	}
type RequesterArrayMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) ([2]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterArrayMock) Get(path string) ([2]string, error) {
	if mock.GetFunc == nil {
		panic("RequesterArrayMock.GetFunc: method is nil but RequesterArray.Get was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArray.GetCalls())
func (mock *RequesterArrayMock) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterArrayMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterArrayMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterElidedMock is a mock implementation of test.RequesterElided.
//
//	func TestSomethingThatUsesRequesterElided(t *testing.T) {
//
//		// make and configure a mocked test.RequesterElided
//		mockedRequesterElided := &RequesterElidedMock{
//			GetFunc: func(path string, url string) error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterElided in code that requires test.RequesterElided
//		// and then make assertions.
//
//	}
type RequesterElidedMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string, url string) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
			// URL is the url argument value.
			URL string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterElidedMock) Get(path string, url string) error {
	if mock.GetFunc == nil {
		panic("RequesterElidedMock.GetFunc: method is nil but RequesterElided.Get was just called")
	}
	callInfo := struct {
		Path string
		URL  string
	}{
		Path: path,
		URL:  url,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(path, url)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterElided.GetCalls())
func (mock *RequesterElidedMock) GetCalls() []struct {
	Path string
	URL  string
} {
	var calls []struct {
		Path string
		URL  string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterElidedMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterElidedMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterIfaceMock is a mock implementation of test.RequesterIface.
//
//	func TestSomethingThatUsesRequesterIface(t *testing.T) {
//
//		// make and configure a mocked test.RequesterIface
//		mockedRequesterIface := &RequesterIfaceMock{
//			GetFunc: func() io.Reader {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterIface in code that requires test.RequesterIface
//		// and then make assertions.
//
//	}
type RequesterIfaceMock struct {
	// GetFunc mocks the Get method.
	GetFunc func() io.Reader

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterIfaceMock) Get() io.Reader {
	if mock.GetFunc == nil {
		panic("RequesterIfaceMock.GetFunc: method is nil but RequesterIface.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterIface.GetCalls())
func (mock *RequesterIfaceMock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterIfaceMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterIfaceMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterNSMock is a mock implementation of test.RequesterNS.
//
//	func TestSomethingThatUsesRequesterNS(t *testing.T) {
//
//		// make and configure a mocked test.RequesterNS
//		mockedRequesterNS := &RequesterNSMock{
//			GetFunc: func(path string) (http.Response, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterNS in code that requires test.RequesterNS
//		// and then make assertions.
//
//	}
type RequesterNSMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (http.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterNSMock) Get(path string) (http.Response, error) {
	if mock.GetFunc == nil {
		panic("RequesterNSMock.GetFunc: method is nil but RequesterNS.Get was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterNS.GetCalls())
func (mock *RequesterNSMock) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterNSMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterNSMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterPtrMock is a mock implementation of test.RequesterPtr.
//
//	func TestSomethingThatUsesRequesterPtr(t *testing.T) {
//
//		// make and configure a mocked test.RequesterPtr
//		mockedRequesterPtr := &RequesterPtrMock{
//			GetFunc: func(path string) (*string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterPtr in code that requires test.RequesterPtr
//		// and then make assertions.
//
//	}
type RequesterPtrMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (*string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterPtrMock) Get(path string) (*string, error) {
	if mock.GetFunc == nil {
		panic("RequesterPtrMock.GetFunc: method is nil but RequesterPtr.Get was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterPtr.GetCalls())
func (mock *RequesterPtrMock) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterPtrMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterPtrMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterReturnElidedMock is a mock implementation of test.RequesterReturnElided.
//
//	func TestSomethingThatUsesRequesterReturnElided(t *testing.T) {
//
//		// make and configure a mocked test.RequesterReturnElided
//		mockedRequesterReturnElided := &RequesterReturnElidedMock{
//			GetFunc: func(path string) (int, int, int, error) {
//				panic("mock out the Get method")
//			},
//			PutFunc: func(path string) (int, error) {
//				panic("mock out the Put method")
//			},
//		}
//
//		// use mockedRequesterReturnElided in code that requires test.RequesterReturnElided
//		// and then make assertions.
//
//	}
type RequesterReturnElidedMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (int, int, int, error)

	// PutFunc mocks the Put method.
	PutFunc func(path string) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
	lockPut sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterReturnElidedMock) Get(path string) (int, int, int, error) {
	if mock.GetFunc == nil {
		panic("RequesterReturnElidedMock.GetFunc: method is nil but RequesterReturnElided.Get was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterReturnElided.GetCalls())
func (mock *RequesterReturnElidedMock) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterReturnElidedMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Put calls PutFunc.
func (mock *RequesterReturnElidedMock) Put(path string) (int, error) {
	if mock.PutFunc == nil {
		panic("RequesterReturnElidedMock.PutFunc: method is nil but RequesterReturnElided.Put was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	mock.lockPut.Unlock()
	return mock.PutFunc(path)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//
//	len(mockedRequesterReturnElided.PutCalls())
func (mock *RequesterReturnElidedMock) PutCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockPut.RLock()
	calls = mock.calls.Put
	mock.lockPut.RUnlock()
	return calls
}

// ResetPutCalls reset all the calls that were made to Put.
func (mock *RequesterReturnElidedMock) ResetPutCalls() {
	mock.lockPut.Lock()
	mock.calls.Put = nil
	mock.lockPut.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterReturnElidedMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockPut.Lock()
	mock.calls.Put = nil
	mock.lockPut.Unlock()
}

// RequesterSliceMock is a mock implementation of test.RequesterSlice.
//
//	func TestSomethingThatUsesRequesterSlice(t *testing.T) {
//
//		// make and configure a mocked test.RequesterSlice
//		mockedRequesterSlice := &RequesterSliceMock{
//			GetFunc: func(path string) ([]string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterSlice in code that requires test.RequesterSlice
//		// and then make assertions.
//
//	}
type RequesterSliceMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) ([]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterSliceMock) Get(path string) ([]string, error) {
	if mock.GetFunc == nil {
		panic("RequesterSliceMock.GetFunc: method is nil but RequesterSlice.Get was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterSlice.GetCalls())
func (mock *RequesterSliceMock) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterSliceMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterSliceMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// requesterUnexportedMock is a mock implementation of test.requesterUnexported.
//
//	func TestSomethingThatUsesrequesterUnexported(t *testing.T) {
//
//		// make and configure a mocked test.requesterUnexported
//		mockedrequesterUnexported := &requesterUnexportedMock{
//			GetFunc: func()  {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedrequesterUnexported in code that requires test.requesterUnexported
//		// and then make assertions.
//
//	}
type requesterUnexportedMock struct {
	// GetFunc mocks the Get method.
	GetFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *requesterUnexportedMock) Get() {
	if mock.GetFunc == nil {
		panic("requesterUnexportedMock.GetFunc: method is nil but requesterUnexported.Get was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedrequesterUnexported.GetCalls())
func (mock *requesterUnexportedMock) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *requesterUnexportedMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *requesterUnexportedMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// RequesterVariadicMock is a mock implementation of test.RequesterVariadic.
//
//	func TestSomethingThatUsesRequesterVariadic(t *testing.T) {
//
//		// make and configure a mocked test.RequesterVariadic
//		mockedRequesterVariadic := &RequesterVariadicMock{
//			GetFunc: func(values ...string) bool {
//				panic("mock out the Get method")
//			},
//			MultiWriteToFileFunc: func(filename string, w ...io.Writer) string {
//				panic("mock out the MultiWriteToFile method")
//			},
//			OneInterfaceFunc: func(a ...interface{}) bool {
//				panic("mock out the OneInterface method")
//			},
//			SprintfFunc: func(format string, a ...interface{}) string {
//				panic("mock out the Sprintf method")
//			},
//		}
//
//		// use mockedRequesterVariadic in code that requires test.RequesterVariadic
//		// and then make assertions.
//
//	}
type RequesterVariadicMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(values ...string) bool

	// MultiWriteToFileFunc mocks the MultiWriteToFile method.
	MultiWriteToFileFunc func(filename string, w ...io.Writer) string

	// OneInterfaceFunc mocks the OneInterface method.
	OneInterfaceFunc func(a ...interface{}) bool

	// SprintfFunc mocks the Sprintf method.
	SprintfFunc func(format string, a ...interface{}) string

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Values is the values argument value.
			Values []string
		}
		// MultiWriteToFile holds details about calls to the MultiWriteToFile method.
		MultiWriteToFile []struct {
			// Filename is the filename argument value.
			Filename string
			// W is the w argument value.
			W []io.Writer
		}
		// OneInterface holds details about calls to the OneInterface method.
		OneInterface []struct {
			// A is the a argument value.
			A []interface{}
		}
		// Sprintf holds details about calls to the Sprintf method.
		Sprintf []struct {
			// Format is the format argument value.
			Format string
			// A is the a argument value.
			A []interface{}
		}
	}
	lockGet              sync.RWMutex
	lockMultiWriteToFile sync.RWMutex
	lockOneInterface     sync.RWMutex
	lockSprintf          sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterVariadicMock) Get(values ...string) bool {
	if mock.GetFunc == nil {
		panic("RequesterVariadicMock.GetFunc: method is nil but RequesterVariadic.Get was just called")
	}
	callInfo := struct {
		Values []string
	}{
		Values: values,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(values...)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterVariadic.GetCalls())
func (mock *RequesterVariadicMock) GetCalls() []struct {
	Values []string
} {
	var calls []struct {
		Values []string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterVariadicMock) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// MultiWriteToFile calls MultiWriteToFileFunc.
func (mock *RequesterVariadicMock) MultiWriteToFile(filename string, w ...io.Writer) string {
	if mock.MultiWriteToFileFunc == nil {
		panic("RequesterVariadicMock.MultiWriteToFileFunc: method is nil but RequesterVariadic.MultiWriteToFile was just called")
	}
	callInfo := struct {
		Filename string
		W        []io.Writer
	}{
		Filename: filename,
		W:        w,
	}
	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = append(mock.calls.MultiWriteToFile, callInfo)
	mock.lockMultiWriteToFile.Unlock()
	return mock.MultiWriteToFileFunc(filename, w...)
}

// MultiWriteToFileCalls gets all the calls that were made to MultiWriteToFile.
// Check the length with:
//
//	len(mockedRequesterVariadic.MultiWriteToFileCalls())
func (mock *RequesterVariadicMock) MultiWriteToFileCalls() []struct {
	Filename string
	W        []io.Writer
} {
	var calls []struct {
		Filename string
		W        []io.Writer
	}
	mock.lockMultiWriteToFile.RLock()
	calls = mock.calls.MultiWriteToFile
	mock.lockMultiWriteToFile.RUnlock()
	return calls
}

// ResetMultiWriteToFileCalls reset all the calls that were made to MultiWriteToFile.
func (mock *RequesterVariadicMock) ResetMultiWriteToFileCalls() {
	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = nil
	mock.lockMultiWriteToFile.Unlock()
}

// OneInterface calls OneInterfaceFunc.
func (mock *RequesterVariadicMock) OneInterface(a ...interface{}) bool {
	if mock.OneInterfaceFunc == nil {
		panic("RequesterVariadicMock.OneInterfaceFunc: method is nil but RequesterVariadic.OneInterface was just called")
	}
	callInfo := struct {
		A []interface{}
	}{
		A: a,
	}
	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = append(mock.calls.OneInterface, callInfo)
	mock.lockOneInterface.Unlock()
	return mock.OneInterfaceFunc(a...)
}

// OneInterfaceCalls gets all the calls that were made to OneInterface.
// Check the length with:
//
//	len(mockedRequesterVariadic.OneInterfaceCalls())
func (mock *RequesterVariadicMock) OneInterfaceCalls() []struct {
	A []interface{}
} {
	var calls []struct {
		A []interface{}
	}
	mock.lockOneInterface.RLock()
	calls = mock.calls.OneInterface
	mock.lockOneInterface.RUnlock()
	return calls
}

// ResetOneInterfaceCalls reset all the calls that were made to OneInterface.
func (mock *RequesterVariadicMock) ResetOneInterfaceCalls() {
	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = nil
	mock.lockOneInterface.Unlock()
}

// Sprintf calls SprintfFunc.
func (mock *RequesterVariadicMock) Sprintf(format string, a ...interface{}) string {
	if mock.SprintfFunc == nil {
		panic("RequesterVariadicMock.SprintfFunc: method is nil but RequesterVariadic.Sprintf was just called")
	}
	callInfo := struct {
		Format string
		A      []interface{}
	}{
		Format: format,
		A:      a,
	}
	mock.lockSprintf.Lock()
	mock.calls.Sprintf = append(mock.calls.Sprintf, callInfo)
	mock.lockSprintf.Unlock()
	return mock.SprintfFunc(format, a...)
}

// SprintfCalls gets all the calls that were made to Sprintf.
// Check the length with:
//
//	len(mockedRequesterVariadic.SprintfCalls())
func (mock *RequesterVariadicMock) SprintfCalls() []struct {
	Format string
	A      []interface{}
} {
	var calls []struct {
		Format string
		A      []interface{}
	}
	mock.lockSprintf.RLock()
	calls = mock.calls.Sprintf
	mock.lockSprintf.RUnlock()
	return calls
}

// ResetSprintfCalls reset all the calls that were made to Sprintf.
func (mock *RequesterVariadicMock) ResetSprintfCalls() {
	mock.lockSprintf.Lock()
	mock.calls.Sprintf = nil
	mock.lockSprintf.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterVariadicMock) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = nil
	mock.lockMultiWriteToFile.Unlock()

	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = nil
	mock.lockOneInterface.Unlock()

	mock.lockSprintf.Lock()
	mock.calls.Sprintf = nil
	mock.lockSprintf.Unlock()
}

// ExampleMock is a mock implementation of test.Example.
//
//	func TestSomethingThatUsesExample(t *testing.T) {
//
//		// make and configure a mocked test.Example
//		mockedExample := &ExampleMock{
//			AFunc: func() http.Flusher {
//				panic("mock out the A method")
//			},
//			BFunc: func(fixtureshttp string) http0.MyStruct {
//				panic("mock out the B method")
//			},
//			CFunc: func(fixtureshttp string) http1.MyStruct {
//				panic("mock out the C method")
//			},
//		}
//
//		// use mockedExample in code that requires test.Example
//		// and then make assertions.
//
//	}
type ExampleMock struct {
	// AFunc mocks the A method.
	AFunc func() http.Flusher

	// BFunc mocks the B method.
	BFunc func(fixtureshttp string) http0.MyStruct

	// CFunc mocks the C method.
	CFunc func(fixtureshttp string) http1.MyStruct

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
		}
		// B holds details about calls to the B method.
		B []struct {
			// Fixtureshttp is the fixtureshttp argument value.
			Fixtureshttp string
		}
		// C holds details about calls to the C method.
		C []struct {
			// Fixtureshttp is the fixtureshttp argument value.
			Fixtureshttp string
		}
	}
	lockA sync.RWMutex
	lockB sync.RWMutex
	lockC sync.RWMutex
}

// A calls AFunc.
func (mock *ExampleMock) A() http.Flusher {
	if mock.AFunc == nil {
		panic("ExampleMock.AFunc: method is nil but Example.A was just called")
	}
	callInfo := struct {
	}{}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	return mock.AFunc()
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedExample.ACalls())
func (mock *ExampleMock) ACalls() []struct {
} {
	var calls []struct {
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *ExampleMock) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// B calls BFunc.
func (mock *ExampleMock) B(fixtureshttp string) http0.MyStruct {
	if mock.BFunc == nil {
		panic("ExampleMock.BFunc: method is nil but Example.B was just called")
	}
	callInfo := struct {
		Fixtureshttp string
	}{
		Fixtureshttp: fixtureshttp,
	}
	mock.lockB.Lock()
	mock.calls.B = append(mock.calls.B, callInfo)
	mock.lockB.Unlock()
	return mock.BFunc(fixtureshttp)
}

// BCalls gets all the calls that were made to B.
// Check the length with:
//
//	len(mockedExample.BCalls())
func (mock *ExampleMock) BCalls() []struct {
	Fixtureshttp string
} {
	var calls []struct {
		Fixtureshttp string
	}
	mock.lockB.RLock()
	calls = mock.calls.B
	mock.lockB.RUnlock()
	return calls
}

// ResetBCalls reset all the calls that were made to B.
func (mock *ExampleMock) ResetBCalls() {
	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()
}

// C calls CFunc.
func (mock *ExampleMock) C(fixtureshttp string) http1.MyStruct {
	if mock.CFunc == nil {
		panic("ExampleMock.CFunc: method is nil but Example.C was just called")
	}
	callInfo := struct {
		Fixtureshttp string
	}{
		Fixtureshttp: fixtureshttp,
	}
	mock.lockC.Lock()
	mock.calls.C = append(mock.calls.C, callInfo)
	mock.lockC.Unlock()
	return mock.CFunc(fixtureshttp)
}

// CCalls gets all the calls that were made to C.
// Check the length with:
//
//	len(mockedExample.CCalls())
func (mock *ExampleMock) CCalls() []struct {
	Fixtureshttp string
} {
	var calls []struct {
		Fixtureshttp string
	}
	mock.lockC.RLock()
	calls = mock.calls.C
	mock.lockC.RUnlock()
	return calls
}

// ResetCCalls reset all the calls that were made to C.
func (mock *ExampleMock) ResetCCalls() {
	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *ExampleMock) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()

	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()

	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// AMock is a mock implementation of test.A.
//
//	func TestSomethingThatUsesA(t *testing.T) {
//
//		// make and configure a mocked test.A
//		mockedA := &AMock{
//			CallFunc: func() (test.B, error) {
//				panic("mock out the Call method")
//			},
//		}
//
//		// use mockedA in code that requires test.A
//		// and then make assertions.
//
//	}
type AMock struct {
	// CallFunc mocks the Call method.
	CallFunc func() (test.B, error)

	// calls tracks calls to the methods.
	calls struct {
		// Call holds details about calls to the Call method.
		Call []struct {
		}
	}
	lockCall sync.RWMutex
}

// Call calls CallFunc.
func (mock *AMock) Call() (test.B, error) {
	if mock.CallFunc == nil {
		panic("AMock.CallFunc: method is nil but A.Call was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCall.Lock()
	mock.calls.Call = append(mock.calls.Call, callInfo)
	mock.lockCall.Unlock()
	return mock.CallFunc()
}

// CallCalls gets all the calls that were made to Call.
// Check the length with:
//
//	len(mockedA.CallCalls())
func (mock *AMock) CallCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCall.RLock()
	calls = mock.calls.Call
	mock.lockCall.RUnlock()
	return calls
}

// ResetCallCalls reset all the calls that were made to Call.
func (mock *AMock) ResetCallCalls() {
	mock.lockCall.Lock()
	mock.calls.Call = nil
	mock.lockCall.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *AMock) ResetCalls() {
	mock.lockCall.Lock()
	mock.calls.Call = nil
	mock.lockCall.Unlock()
}

// StructWithTagMock is a mock implementation of test.StructWithTag.
//
//	func TestSomethingThatUsesStructWithTag(t *testing.T) {
//
//		// make and configure a mocked test.StructWithTag
//		mockedStructWithTag := &StructWithTagMock{
//			MethodAFunc: func(v *struct{FieldA int "json:\"field_a\""; FieldB int "json:\"field_b\" xml:\"field_b\""}) *struct{FieldC int "json:\"field_c\""; FieldD int "json:\"field_d\" xml:\"field_d\""} {
//				panic("mock out the MethodA method")
//			},
//		}
//
//		// use mockedStructWithTag in code that requires test.StructWithTag
//		// and then make assertions.
//
//	}
type StructWithTagMock struct {
	// MethodAFunc mocks the MethodA method.
	MethodAFunc func(v *struct {
		FieldA int "json:\"field_a\""
		FieldB int "json:\"field_b\" xml:\"field_b\""
	}) *struct {
		FieldC int "json:\"field_c\""
		FieldD int "json:\"field_d\" xml:\"field_d\""
	}

	// calls tracks calls to the methods.
	calls struct {
		// MethodA holds details about calls to the MethodA method.
		MethodA []struct {
			// V is the v argument value.
			V *struct {
				FieldA int "json:\"field_a\""
				FieldB int "json:\"field_b\" xml:\"field_b\""
			}
		}
	}
	lockMethodA sync.RWMutex
}

// MethodA calls MethodAFunc.
func (mock *StructWithTagMock) MethodA(v *struct {
	FieldA int "json:\"field_a\""
	FieldB int "json:\"field_b\" xml:\"field_b\""
}) *struct {
	FieldC int "json:\"field_c\""
	FieldD int "json:\"field_d\" xml:\"field_d\""
} {
	if mock.MethodAFunc == nil {
		panic("StructWithTagMock.MethodAFunc: method is nil but StructWithTag.MethodA was just called")
	}
	callInfo := struct {
		V *struct {
			FieldA int "json:\"field_a\""
			FieldB int "json:\"field_b\" xml:\"field_b\""
		}
	}{
		V: v,
	}
	mock.lockMethodA.Lock()
	mock.calls.MethodA = append(mock.calls.MethodA, callInfo)
	mock.lockMethodA.Unlock()
	return mock.MethodAFunc(v)
}

// MethodACalls gets all the calls that were made to MethodA.
// Check the length with:
//
//	len(mockedStructWithTag.MethodACalls())
func (mock *StructWithTagMock) MethodACalls() []struct {
	V *struct {
		FieldA int "json:\"field_a\""
		FieldB int "json:\"field_b\" xml:\"field_b\""
	}
} {
	var calls []struct {
		V *struct {
			FieldA int "json:\"field_a\""
			FieldB int "json:\"field_b\" xml:\"field_b\""
		}
	}
	mock.lockMethodA.RLock()
	calls = mock.calls.MethodA
	mock.lockMethodA.RUnlock()
	return calls
}

// ResetMethodACalls reset all the calls that were made to MethodA.
func (mock *StructWithTagMock) ResetMethodACalls() {
	mock.lockMethodA.Lock()
	mock.calls.MethodA = nil
	mock.lockMethodA.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *StructWithTagMock) ResetCalls() {
	mock.lockMethodA.Lock()
	mock.calls.MethodA = nil
	mock.lockMethodA.Unlock()
}

// VariadicMock is a mock implementation of test.Variadic.
//
//	func TestSomethingThatUsesVariadic(t *testing.T) {
//
//		// make and configure a mocked test.Variadic
//		mockedVariadic := &VariadicMock{
//			VariadicFunctionFunc: func(str string, vFunc test.VariadicFunction) error {
//				panic("mock out the VariadicFunction method")
//			},
//		}
//
//		// use mockedVariadic in code that requires test.Variadic
//		// and then make assertions.
//
//	}
type VariadicMock struct {
	// VariadicFunctionFunc mocks the VariadicFunction method.
	VariadicFunctionFunc func(str string, vFunc test.VariadicFunction) error

	// calls tracks calls to the methods.
	calls struct {
		// VariadicFunction holds details about calls to the VariadicFunction method.
		VariadicFunction []struct {
			// Str is the str argument value.
			Str string
			// VFunc is the vFunc argument value.
			VFunc test.VariadicFunction
		}
	}
	lockVariadicFunction sync.RWMutex
}

// VariadicFunction calls VariadicFunctionFunc.
func (mock *VariadicMock) VariadicFunction(str string, vFunc test.VariadicFunction) error {
	if mock.VariadicFunctionFunc == nil {
		panic("VariadicMock.VariadicFunctionFunc: method is nil but Variadic.VariadicFunction was just called")
	}
	callInfo := struct {
		Str   string
		VFunc test.VariadicFunction
	}{
		Str:   str,
		VFunc: vFunc,
	}
	mock.lockVariadicFunction.Lock()
	mock.calls.VariadicFunction = append(mock.calls.VariadicFunction, callInfo)
	mock.lockVariadicFunction.Unlock()
	return mock.VariadicFunctionFunc(str, vFunc)
}

// VariadicFunctionCalls gets all the calls that were made to VariadicFunction.
// Check the length with:
//
//	len(mockedVariadic.VariadicFunctionCalls())
func (mock *VariadicMock) VariadicFunctionCalls() []struct {
	Str   string
	VFunc test.VariadicFunction
} {
	var calls []struct {
		Str   string
		VFunc test.VariadicFunction
	}
	mock.lockVariadicFunction.RLock()
	calls = mock.calls.VariadicFunction
	mock.lockVariadicFunction.RUnlock()
	return calls
}

// ResetVariadicFunctionCalls reset all the calls that were made to VariadicFunction.
func (mock *VariadicMock) ResetVariadicFunctionCalls() {
	mock.lockVariadicFunction.Lock()
	mock.calls.VariadicFunction = nil
	mock.lockVariadicFunction.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *VariadicMock) ResetCalls() {
	mock.lockVariadicFunction.Lock()
	mock.calls.VariadicFunction = nil
	mock.lockVariadicFunction.Unlock()
}

// VariadicReturnFuncMock is a mock implementation of test.VariadicReturnFunc.
//
//	func TestSomethingThatUsesVariadicReturnFunc(t *testing.T) {
//
//		// make and configure a mocked test.VariadicReturnFunc
//		mockedVariadicReturnFunc := &VariadicReturnFuncMock{
//			SampleMethodFunc: func(str string) func(str string, arr []int, a ...interface{}) {
//				panic("mock out the SampleMethod method")
//			},
//		}
//
//		// use mockedVariadicReturnFunc in code that requires test.VariadicReturnFunc
//		// and then make assertions.
//
//	}
type VariadicReturnFuncMock struct {
	// SampleMethodFunc mocks the SampleMethod method.
	SampleMethodFunc func(str string) func(str string, arr []int, a ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// SampleMethod holds details about calls to the SampleMethod method.
		SampleMethod []struct {
			// Str is the str argument value.
			Str string
		}
	}
	lockSampleMethod sync.RWMutex
}

// SampleMethod calls SampleMethodFunc.
func (mock *VariadicReturnFuncMock) SampleMethod(str string) func(str string, arr []int, a ...interface{}) {
	if mock.SampleMethodFunc == nil {
		panic("VariadicReturnFuncMock.SampleMethodFunc: method is nil but VariadicReturnFunc.SampleMethod was just called")
	}
	callInfo := struct {
		Str string
	}{
		Str: str,
	}
	mock.lockSampleMethod.Lock()
	mock.calls.SampleMethod = append(mock.calls.SampleMethod, callInfo)
	mock.lockSampleMethod.Unlock()
	return mock.SampleMethodFunc(str)
}

// SampleMethodCalls gets all the calls that were made to SampleMethod.
// Check the length with:
//
//	len(mockedVariadicReturnFunc.SampleMethodCalls())
func (mock *VariadicReturnFuncMock) SampleMethodCalls() []struct {
	Str string
} {
	var calls []struct {
		Str string
	}
	mock.lockSampleMethod.RLock()
	calls = mock.calls.SampleMethod
	mock.lockSampleMethod.RUnlock()
	return calls
}

// ResetSampleMethodCalls reset all the calls that were made to SampleMethod.
func (mock *VariadicReturnFuncMock) ResetSampleMethodCalls() {
	mock.lockSampleMethod.Lock()
	mock.calls.SampleMethod = nil
	mock.lockSampleMethod.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *VariadicReturnFuncMock) ResetCalls() {
	mock.lockSampleMethod.Lock()
	mock.calls.SampleMethod = nil
	mock.lockSampleMethod.Unlock()
}
