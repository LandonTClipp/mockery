{{ .Boilerplate }}
// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery

{{- if .BuildTags }}

//go:build {{ .BuildTags }}
{{- end }}

package {{.PkgName}}

import (
{{- range .Imports}}
	{{. | ImportStatement}}
{{- end}}
    mock "github.com/stretchr/testify/mock"
)

{{- range $i, $mock := .Mocks }} {{/* START MOCK RANGE */}}
// New{{ .MockName }} creates a new instance of {{ .MockName }}. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func New{{ .MockName }}{{ $mock | TypeConstraint }} (t interface {
	mock.TestingT
	Cleanup(func())
}) *{{ .MockName }}{{ $mock | TypeInstantiation }} {
	mock := &{{ .MockName }}{{ $mock | TypeInstantiation }}{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}


// {{ .MockName }} is an autogenerated mock type for the {{ .InterfaceName }} type
type {{ .MockName }}{{ $mock | TypeConstraint }} struct {
	mock.Mock
}

{{- range $methodIdx, $method := .Methods }} {{/* START METHOD RANGE */}}

// {{ $method.Name }} provides a mock function for the type {{ $mock.MockName }}
func (_mock *{{$mock.MockName}}{{ $mock | TypeInstantiation }}) {{$method.Name}}({{$method.ArgList}}) {{$method.ReturnArgTypeList}} {
	{{- if ne (len $method.Returns) 0 }}
	var retArgs mock.Arguments
	{{- end }}
{{- if or
	(eq (len $method.ArgList) 0)
	(not $method.IsVariadic)
	(not (index $mock.TemplateData "unroll-variadic"))
}} {{/* START PREAMBLE */}}
	{{- if and
		($method.IsVariadic)
		(not (index $mock.TemplateData "unroll-variadic"))
	}}
	{{- $lastParam := index $method.Params (len $method.Params | Add -1 )}}
	if len({{ $lastParam.Var.Name }}) > 0 {
		retArgs = _mock.Called({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallList }}{{- else }}{{ $method.ArgCallListNoEllipsis }}{{- end }})
	} else {
		retArgs = _mock.Called({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallListSlice 0 (len $method.Params | Add -1 )}}{{- else }}{{ $method.ArgCallListSliceNoEllipsis 0 (len $method.Params | Add -1 )}}{{- end }})
	}
	{{- end }}
{{- else }}
	/* TODO: finish https://github.com/vektra/mockery/blob/ede4f2c90f854f51c8618c934930f7bf6cdb5a5d/pkg/generator.go#L1109-L1153 */
{{- end }}
{{/* END PREAMBLE */}}
	{{- if eq (len $method.Returns) 0 }}
	_mock.Called({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallList }}{{- else }}{{ $method.ArgCallListNoEllipsis }}{{- end }})
	{{- else }}
	if retArgs == nil {
		retArgs = _mock.Called({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallList }}{{- else }}{{ $method.ArgCallListNoEllipsis }}{{- end }})
	}


	if len(retArgs) == 0 {
		panic("no return value specified for {{$mock.MockName}}.{{$method.Name}}")
	}

	var (
		{{- range $retIdx, $ret := $method.Returns }}
		retVal{{ $retIdx }} {{ (index $method.Returns $retIdx).TypeString }}
		{{- end }}
	)

		{{- if gt (len $method.Returns) 1 }}
	if returnFunc, ok := retArgs.Get(0).(func({{ $method.ArgTypeList }}) {{ $method.ReturnArgTypeList }}); ok {
		return returnFunc({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallList }}{{- else }}{{ $method.ArgCallListNoEllipsis }}{{- end }})
	}
		{{- end }}

		{{- range $retIdx, $ret := $method.Returns }} {{/* START RETURN RANGE */}}
	if returnFunc, ok := retArgs.Get({{ $retIdx }}).(func({{$method.ArgTypeListEllipsis }}) {{ (index $method.Returns $retIdx).TypeString }}); ok {
		retVal{{ $retIdx }} = returnFunc({{ $method.ArgCallList }})
	} else {
		{{- if eq "error" (index $method.Returns $retIdx).TypeString }}
		retVal{{ $retIdx }} = retArgs.Error({{ $retIdx }})
		{{- else if (index $method.Returns $retIdx).Var.Nillable }}
		if retArgs.Get({{ $retIdx }}) != nil {
			retVal{{ $retIdx }} = retArgs.Get({{ $retIdx }}).({{ (index $method.Returns $retIdx).TypeString }})
		}
		{{- else }}
		retVal{{ $retIdx }} = retArgs.Get({{ $retIdx }}).({{ (index $method.Returns $retIdx).TypeString }})
		{{- end }}
	}
		{{- end }} {{/* END RETURN RANGE */}}
	{{- end }}
	return {{ range $retIdx, $ret := $method.Returns }}retVal{{ $retIdx }}{{ if ne $retIdx (len $method.Returns | Add -1) }}, {{ end }}{{ end }}
}
{{- end }} {{/* END METHOD RANGE */}}


type {{.MockName}}_expecter{{ $mock | TypeConstraint }} struct {
	mock *mock.Mock
}

func (_m *{{.MockName}}{{ $mock | TypeInstantiation }}) EXPECT() *{{.MockName}}_expecter{{ $mock | TypeInstantiation }} {
	return &{{.MockName}}_expecter{{ $mock | TypeInstantiation }}{mock: &_m.Mock}
}
{{- end }} {{/* END MOCK RANGE */}}

