{{ .Boilerplate }}
// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
{{- if .BuildTags }}

//go:build {{ .BuildTags }}
{{- end }}

package {{.PkgName}}

import (
{{- range .Imports}}
	{{. | ImportStatement}}
{{- end}}
    mock "github.com/stretchr/testify/mock"
)

{{- range $i, $mock := .Mocks }} {{/* START MOCK RANGE */}}
// New{{ .MockName }} creates a new instance of {{ .MockName }}. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func New{{ .MockName }}{{ $mock | TypeConstraint }} (t interface {
	mock.TestingT
	Cleanup(func())
}) *{{ .MockName }}{{ $mock | TypeInstantiation }} {
	mock := &{{ .MockName }}{{ $mock | TypeInstantiation }}{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}


// {{ .MockName }} is an autogenerated mock type for the {{ .InterfaceName }} type
type {{ .MockName }}{{ $mock | TypeConstraint }} struct {
	mock.Mock
}

{{- range $methodIdx, $method := .Methods }} {{/* START METHOD RANGE */}}

// {{ $method.Name }} provides a mock function for the type {{ $mock.MockName }}
func (_mock *{{$mock.MockName}}{{ $mock | TypeInstantiation }}) {{$method.Name}}({{$method.ArgList}}) {{$method.ReturnArgTypeList}} {
	{{- $calledString := "" }}
{{- if or
	(eq (len $method.ArgList) 0)
	(not $method.IsVariadic)
	(not (index $mock.TemplateData "unroll-variadic"))
}} {{/* START PREAMBLE */}}
	{{- if and
		($method.IsVariadic)
		(not (index $mock.TemplateData "unroll-variadic"))
	}}

	{{- if ne (len $method.Returns) 0}}
	var tmpRet mock.Arguments
	{{- $calledString = "tmpRet" }}
	{{- else }}
	{{- $calledString = "" }}
	{{- end }}

	{{- $lastParam := index $method.Params (len $method.Params | Add -1 )}}
	if len({{ $lastParam.Var.Name }}) > 0 {
		{{- if ne (len $method.Returns) 0}}tmpRet = {{ end }}_mock.Called({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallList }}{{- else }}{{ $method.ArgCallListNoEllipsis }}{{- end }})
	} else {
		{{- if ne (len $method.Returns) 0}}tmpRet = {{ end }}_mock.Called({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallListSlice 0 (len $method.Params | Add -1 )}}{{- else }}{{ $method.ArgCallListSliceNoEllipsis 0 (len $method.Params | Add -1 )}}{{- end }})
	}
	{{- else }}
	{{- $calledString = printf "_mock.Called(%s)" $method.ArgCallList }}
	{{- end }}
{{- else }}
	{{- $lastParam := (index $method.Params (len $method.Params | Add -1)) }}
	{{- $variadicArgsName := $lastParam.Var.Name }}
	{{- $strippedTypeString := TrimPrefix "..." $lastParam.TypeStringEllipsis }}

	{{- if and (ne $strippedTypeString "interface{}") (ne $strippedTypeString "any") }}
	// {{ $strippedTypeString }}
	_va := make([]interface{}, len({{- $lastParam.Var.Name }}))
	for _i := range {{ $lastParam.Var.Name }} {
		_va[_i] = {{ $lastParam.Var.Name }}[_i]
	}
		{{- $variadicArgsName = "_va" }}
	{{- end }}
	var _ca []interface{}
	{{- if gt (len $method.Params) 1 }}
	_ca = append(_ca, {{ $method.ArgCallListSlice 0 (len $method.Params | Add -1) }})
	{{- end }}
	_ca = append(_ca, {{ $variadicArgsName }}...)
	{{- $calledString = "_mock.Called(_ca...)" }}
{{- end }} {{/* END PREAMBLE */}}
	{{- if eq (len $method.Returns) 0 }}
	{{- $calledString }}
	{{- else }}
	ret := {{ $calledString }}

	if len(ret) == 0 {
		panic("no return value specified for {{$method.Name}}")
	}

		{{ range $retIdx, $ret := $method.Returns }}
	var r{{ $retIdx }} {{ (index $method.Returns $retIdx).TypeString }}
		{{- end }}

		{{- if gt (len $method.Returns) 1 }}
	if returnFunc, ok := ret.Get(0).(func({{ $method.ArgTypeList }}) {{ $method.ReturnArgTypeList }}); ok {
		return returnFunc({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallList }}{{- else }}{{ $method.ArgCallListNoEllipsis }}{{- end }})
	}
		{{- end }}

		{{- range $retIdx, $ret := $method.Returns }} {{/* START RETURN RANGE */}}
	if returnFunc, ok := ret.Get({{ $retIdx }}).(func({{$method.ArgTypeListEllipsis }}) {{ (index $method.Returns $retIdx).TypeString }}); ok {
		r{{ $retIdx }} = returnFunc({{ $method.ArgCallList }})
	} else {
		{{- if eq "error" (index $method.Returns $retIdx).TypeString }}
		r{{ $retIdx }} = ret.Error({{ $retIdx }})
		{{- else if (index $method.Returns $retIdx).Var.Nillable }}
		if ret.Get({{ $retIdx }}) != nil {
			r{{ $retIdx }} = ret.Get({{ $retIdx }}).({{ (index $method.Returns $retIdx).TypeString }})
		}
		{{- else }}
		r{{ $retIdx }} = ret.Get({{ $retIdx }}).({{ (index $method.Returns $retIdx).TypeString }})
		{{- end }}
	}
		{{- end }} {{/* END RETURN RANGE */}}
	{{- end }}
	return {{ range $retIdx, $ret := $method.Returns }}r{{ $retIdx }}{{ if ne $retIdx (len $method.Returns | Add -1) }}, {{ end }}{{ end }}
}
{{- end }} {{/* END METHOD RANGE */}}


type {{.MockName}}_expecter{{ $mock | TypeConstraint }} struct {
	mock *mock.Mock
}

func (_m *{{.MockName}}{{ $mock | TypeInstantiation }}) EXPECT() *{{.MockName}}_expecter{{ $mock | TypeInstantiation }} {
	return &{{.MockName}}_expecter{{ $mock | TypeInstantiation }}{mock: &_m.Mock}
}
{{- end }} {{/* END MOCK RANGE */}}

