Templates
=========

Mockery, in its essence, renders templates. This project provides a number of pre-curated
templates that you can select with the `#!yaml template:` config parameter.

## Template Options

### `#!yaml template: "mockery"`

Choosing this template will render a traditional "mockery-style" template. The
section below shows what will be rendered for the given interface.

=== "Interface"

    ```go
    package test

    type Requester interface {
        Get(path string) (string, error)
    }
    ```

=== "`.mockery.yml`"

    ```yaml
    template: mockery
    packages:
        github.com/vektra/mockery/v3/pkg/fixtures:
            config:
                dir: "{{.InterfaceDir}}"
                filename: "mocks.go"
                pkgname: "test"
                mockname: "Mock{{.InterfaceName}}"
            interfaces:
                Requester:
    ```

=== "`mocks.go`"

    ```go
    // Code generated by mockery; DO NOT EDIT.
    // github.com/vektra/mockery

    package test

    import (
        mock "github.com/stretchr/testify/mock"
    )


    // NewRequester creates a new instance of Requester. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
    // The first argument is typically a *testing.T value.
    func NewRequester (t interface {
        mock.TestingT
        Cleanup(func())
    }) *Requester {
       // ...
    }


    // Requester is an autogenerated mock type for the Requester type
    type Requester struct {
        mock.Mock
    }

    type Requester_Expecter struct {
        mock *mock.Mock
    }

    func (_m *Requester) EXPECT() *Requester_Expecter {
        // ...
    }



    // Get provides a mock function for the type Requester
    func (_mock *Requester) Get(path string) (string, error) {
        // ...
    }



    // Requester_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
    type Requester_Get_Call struct {
        *mock.Call
    }



    // Get is a helper method to define mock.On call
    //  - path
    func (_e *Requester_Expecter) Get(path interface{}, ) *Requester_Get_Call {
        // ...
    }

    func (_c *Requester_Get_Call) Run(run func(path string)) *Requester_Get_Call {
       // ...
    }

    func (_c *Requester_Get_Call) Return(s string, err error) *Requester_Get_Call {
        // ...
    }

    func (_c *Requester_Get_Call) RunAndReturn(run func(path string)(string, error)) *Requester_Get_Call {
        // ...
    }
    ```

=== "Example Usage"

    ```go
    package test

    import (
        "testing"

        "github.com/stretchr/testify/assert"
    )

    func TestRequesterMock(t *testing.T) {
        m := NewMockRequester(t)
        m.EXPECT().Get("foo").Return("bar", nil).Once()
        retString, err := m.Get("foo")
        assert.NoError(t, err)
        assert.Equal(t, retString, "bar")
    }
    ```

As you can see, this mock utilizes `github.com/stretchr/testify` under the hood and registers call expectations with testify. When the mock receives a call to `Get()`, it retrieves the expected value from testify to be returned.

This style of mock also has other interesting methods:

=== "`#!go Run()`"

    Run a side effect when the argument matches.

    ```go
    func TestRequesterMockRun(t *testing.T) {
        m := NewMockRequester(t)
        m.EXPECT().Get(mock.Anything).Return("", nil)
        m.EXPECT().Get(mock.Anything).Run(func(path string) {
            fmt.Printf("Side effect! Argument is: %s", path)
        })
        retString, err := m.Get("hello")
        assert.NoError(t, err)
        assert.Equal(t, retString, "")
    }
    ```

=== "`#!go RunAndReturn()`"

    Run a function to perform side-effects, and return the result of the function.

    ```go
    func TestRequesterMockRunAndReturn(t *testing.T) {
        m := NewMockRequester(t)
        m.EXPECT().Get(mock.Anything).RunAndReturn(func(path string) (string, error) {
            return path + " world", nil
        })
        retString, err := m.Get("hello")
        assert.NoError(t, err)
        assert.Equal(t, retString, "hello world")
    }
    ```

=== "`github.com/stretchr/testify/mock.Mock`"

    Because the mock embeds the testify `Mock` object, you can all any methods on that as well.

    ```go
    func TestRequesterMockTestifyEmbed(t *testing.T) {
        m := NewMockRequester(t)
        m.EXPECT().Get(mock.Anything).Return("", nil).Twice()
        m.Get("hello")
        m.Get("world")
        assert.Equal(t, len(m.Mock.Calls), 2)
    }
    ```
#### `template-data`

| key | type | description |
|-----|------|-------------|
| `unroll-variadic` | `#!yaml bool` | If set to `#!yaml true`, will expand the variadic argument to testify using the `...` syntax. See [notes](./notes.md#variadic-arguments) for more details. |

### `#!yaml template: "moq"`

`moq` templates draw from the mocks generated from the project at https://github.com/matryer/moq. This project was folded into mockery, and thus moq-style mocks can be natively generated from within mockery.


=== "Interface"

    ```go
    package test

    type Requester interface {
        Get(path string) (string, error)
    }
    ```

=== "`.mockery.yml`"

    ```yaml
    template: moq
    packages:
        github.com/vektra/mockery/v3/pkg/fixtures:
            config:
                dir: "{{.InterfaceDir}}"
                filename: "mocks_moq.go"
                pkgname: "test"
                mockname: "Moq{{.InterfaceName}}"
            interfaces:
                Requester:
    ```

=== "`mocks_moq.go`"

    ```go
    // Code generated by mockery; DO NOT EDIT.
    // github.com/vektra/mockery

    package test

    import (
        "sync"
    )

    // Ensure, that MoqRequester does implement Requester.
    // If this is not the case, regenerate this file with moq.
    var _ Requester = &MoqRequester{}

    // MoqRequester is a mock implementation of Requester.
    //
    //	func TestSomethingThatUsesRequester(t *testing.T) {
    //
    //		// make and configure a mocked Requester
    //		mockedRequester := &MoqRequester{
    //			GetFunc: func(path string) (string, error) {
    //				panic("mock out the Get method")
    //			},
    //		}
    //
    //		// use mockedRequester in code that requires Requester
    //		// and then make assertions.
    //
    //	}
    type MoqRequester struct {
        // GetFunc mocks the Get method.
        GetFunc func(path string) (string, error)

        // calls tracks calls to the methods.
        calls struct {
            // Get holds details about calls to the Get method.
            Get []struct {
                // Path is the path argument value.
                Path string
            }
        }
        lockGet sync.RWMutex
    }

    // Get calls GetFunc.
    func (mock *MoqRequester) Get(path string) (string, error) {
       // ...
    }

    // GetCalls gets all the calls that were made to Get.
    // Check the length with:
    //
    //	len(mockedRequester.GetCalls())
    func (mock *MoqRequester) GetCalls() []struct {
        Path string
    } {
        // ...
    }

    ```

=== "Example Usage"

    ```go
    func TestRequesterMoq(t *testing.T) {
        m := &MoqRequester{
            GetFunc: func(path string) (string, error) {
                fmt.Printf("Go path: %s\n", path)
                return path + "/foo", nil
            },
        }
        result, err := m.Get("/path")
        assert.NoError(t, err)
        assert.Equal(t, "/path/foo", result)
    }
    ```

Moq-style mocks are far simpler, and probably more intuitive, than mockery-style mocks. All that's needed is to define the function that will be run when the mock's method is called.

#### `template-data`

`moq` accepts the following `#!yaml template-data:` keys:

| key | type | description |
|-----|------|-------------|
| `skip-ensure` | `#!yaml bool` | Suppress mock implementation check, avoid import cycle if mocks generated outside of the tested package. |
| `stub-impl` | `#!yaml bool` | Return zero values when no mock implementation is provided, do not panic. |

### `#!yaml template: "file://`

You may also provide mockery a path to your own file using the `file://` protocol specifier. The string after `file://` will be the relative or absolute path of your template.

## Data Provided To Templates

!!! warning "Construction"

    This section is under construction.

mockery configuration makes use of the Go templating system.

### Variables

!!! note
    Templated variables are only available when using the `packages` config feature.

Variables that are marked as being templated are capable of using mockery-provided template parameters.

| name                    | description                                                                                                                                                                                                                                                                                   |
|-------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ConfigDir               | The directory path of the config file used. This is used to allow generation of mocks in a directory relative to the `.mockery.yaml` file, e.g. external interfaces.                                                                                                                          |
| InterfaceDir            | The directory path of the original interface being mocked. This can be used as <br>`#!yaml dir: "{{.InterfaceDir}}"` to place your mocks adjacent to the original interface. This should not be used for external interfaces.                                                                 |
| InterfaceDirRelative    | The directory path of the original interface being mocked, relative to the current working directory. If the path cannot be made relative to the current working directory, this variable will be set equal to `PackagePath`                                                                  |
| InterfaceFile           | The file path of the original interface being mocked. **NOTE:** This option will only write one mock implementation to the output file. If multiple mocks are defined in your original file, only one mock will be written to the output.                                                     |
| InterfaceName           | The name of the original interface being mocked                                                                                                                                                                                                                                               |
| InterfaceNameCamel      | Converts a string `interface_name` to `InterfaceName`. <br /><b style="color:var(--md-code-hl-number-color);">DEPRECATED</b>: use `{{ .InterfaceName | camelcase }}` instead                                                                                                                                                                     |
| InterfaceNameLowerCamel | Converts `InterfaceName` to `interfaceName` . <br /><b style="color:var(--md-code-hl-number-color);">DEPRECATED</b>: use `{{ .InterfaceName | camelcase | firstLower }}` instead                                                                                                                                                                |
| InterfaceNameSnake      | Converts `InterfaceName` to `interface_name` . <br /><b style="color:var(--md-code-hl-number-color);">DEPRECATED</b>: use `{{ .InterfaceName | snakecase }}` instead                                                                                                                                                                             |
| InterfaceNameLower      | Converts `InterfaceName` to `interfacename` . <br /><b style="color:var(--md-code-hl-number-color);">DEPRECATED</b>: use `{{ .InterfaceName | lower }}` instead                                                                                                                                                                                  |
| Mock                    | A string that is `Mock` if the interface is exported, or `mock` if it is not exported. Useful when setting the name of your mock to something like: <br>`#!yaml mockname: "{{.Mock}}{{.InterfaceName}}"`<br> This way, the mock name will retain the exported-ness of the original interface. |
| MockName                | The name of the mock that will be generated. Note that this is simply the `mockname` configuration variable                                                                                                                                                                                   |
| PackageName             | The name of the package from the original interface                                                                                                                                                                                                                                           |
| PackagePath             | The fully qualified package path of the original interface                                                                                                                                                                                                                                    |

### Functions

!!! note
    Templated functions are only available when using the `packages` config feature.

Template functions allow you to inspect and manipulate template variables.

All template functions are calling native Go functions under the hood, so signatures and return values matches the Go functions you are probably already familiar with.

To learn more about the templating syntax, please [see the Go `text/template` documentation](https://pkg.go.dev/text/template)

* [`contains` string substr](https://pkg.go.dev/strings#Contains)
* [`hasPrefix` string prefix](https://pkg.go.dev/strings#HasPrefix)
* [`hasSuffix` string suffix](https://pkg.go.dev/strings#HasSuffix)
* [`join` elems sep](https://pkg.go.dev/strings#Join)
* [`replace` string old new n](https://pkg.go.dev/strings#Replace)
* [`replaceAll` string old new](https://pkg.go.dev/strings#ReplaceAll)
* [`split` string sep](https://pkg.go.dev/strings#Split)
* [`splitAfter` string sep](https://pkg.go.dev/strings#SplitAfter)
* [`splitAfterN` string sep n](https://pkg.go.dev/strings#SplitAfterN)
* [`trim` string cutset](https://pkg.go.dev/strings#Trim)
* [`trimLeft` string cutset](https://pkg.go.dev/strings#TrimLeft)
* [`trimPrefix` string prefix](https://pkg.go.dev/strings#TrimPrefix)
* [`trimRight` string cutset](https://pkg.go.dev/strings#TrimRight)
* [`trimSpace` string](https://pkg.go.dev/strings#TrimSpace)
* [`trimSuffix` string suffix](https://pkg.go.dev/strings#TrimSuffix)
* [`lower` string](https://pkg.go.dev/strings#ToLower)
* [`upper` string](https://pkg.go.dev/strings#ToUpper)
* [`camelcase` string](https://pkg.go.dev/github.com/huandu/xstrings#ToCamelCase)
* [`snakecase` string](https://pkg.go.dev/github.com/huandu/xstrings#ToSnakeCase)
* [`kebabcase` string](https://pkg.go.dev/github.com/huandu/xstrings#ToKebabCase)
* [`firstLower` string](https://pkg.go.dev/github.com/huandu/xstrings#FirstRuneToLower)
* [`firstUpper` string](https://pkg.go.dev/github.com/huandu/xstrings#FirstRuneToUpper)
* [`matchString` pattern](https://pkg.go.dev/regexp#MatchString)
* [`quoteMeta` string](https://pkg.go.dev/regexp#QuoteMeta)
* [`base` string](https://pkg.go.dev/path/filepath#Base)
* [`clean` string](https://pkg.go.dev/path/filepath#Clean)
* [`dir` string](https://pkg.go.dev/path/filepath#Dir)
* [`expandEnv` string](https://pkg.go.dev/os#ExpandEnv)
* [`getenv` string](https://pkg.go.dev/os#Getenv)
